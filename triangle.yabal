
import "float.yabal"

var floats = create_pointer<Float16>(0x0, 1);
var signedInts = create_pointer<SignedInt>(0x1111, 1);

var screen = create_pointer(53871, 1)

var expansionPorts = create_pointer(53500, 1)

var chars = create_pointer(53546, 1)
var offset = 0

const Float16 FLOAT_ZERO = { sign : 0, exponent : 0, fraction : 0 };
const Float16 ONE = { sign : 0, exponent : 0b01111, fraction : 0 };

// inline int get_color(int r, int g, int b) {
//     return (r / 8 << 10) + (g / 8 << 5) + (b / 8);
// }

// int sign (int p1x, int p1y, int p2x, int p2y, int p3x, int p3y)
// {
//     return ((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y))
// }

// int PointInTriangle (int px, int py, int t1x, int t1y, int t2x, int t2y, int t3x, int t3y)
// {
//     var d1 = 0
//     var d2 = 0
//     var d3 = 0
//     var has_neg = false
//     var has_pos = false

//     d1 = sign(px, py, t1x, t1y, t2x, t2y)
//     d2 = sign(px, py, t2x, t2y, t3x, t3y)
//     d3 = sign(px, py, t3x, t3y, t1x, t1y)

//     has_neg = (d1 > 60000) || (d2 > 60000) || (d3 > 60000)
//     has_pos = (d1 < 60000) || (d2 < 60000) || (d3 < 60000)

//     return !(has_neg && has_pos)
// }

// // Function foor drawign a single pixel to the screen
// void SetPixel(int x, int y, int color){
//     var screenOffset = (y * 108) + x
//     screen[screenOffset] = color
// }


// // Bresenham's line algorithm
// void DrawLine(Float16 x1, Float16 y1, Float16 x2, Float16 y2, int color)
// {
//   bool steep = false
//   Float16 y2y1sub = fabs(SubFloats(y2 - y1))
//   Float16 x2x1sub = fabs(SubFloats(x2 - x1))
//   // Compare if y2y1sub is greater than x2x1sub
//   if(y2y1sub.exponent-15 >= x2x1sub.exponent-15){
//     if(y2y1sub.fraction > x2x1sub.fraction)
//         steep = true
//   }
// else if(y2y1sub.exponent-15 == x2x1sub.exponent-15){
//   steep = true
// }
//   if(steep)
//   {
//     // Swap x1 and y1
//     Float16 tmpx1 = x1
//     x1 = y1
//     y1 = tmpx1
//     // Swap x2 and y2
//     Float16 tmpx2 = x2
//     x2 = y2
//     y2 = tmpx2
//   }

//   if(x1 > x2)
//   {
//     // Swap x1 and x2
//     Float16 tmpx1 = x1
//     x1 = x2
//     x2 = tmpx1
//     // Swap y1 and y2
//     Float16 tmpy1 = y1
//     y1 = y2
//     y2 = tmpy1
//   }

//   Float16 dx = SubFloats(x2 - x1)
//   Float16 dy = fabs(SubFloats(y2 - y1))
  
//   //Float16 two = { sign : 0, exponent : 10000, fraction : 0 };
//   Float16 error = DivFloats(dx, IntToFloat(2))
//   SignedInt ystep = {s:0, val:1};
//   if (y1 < y2){
//       ystep.s = 0
//   }
//   else{
//       ystep.s = 1
//   }
//   SignedInt y = IntToSignedInt(FloatToInt(y1))

//   SignedInt maxX = FloatToInt(x2)

//   var strt = FloatToInt(x1)
//   for(var x=strt; x<=maxX.val; x++)
//   {
//     if(steep)
//         SetPixel(y.val,x, color)
//     else
//         SetPixel(x,y.val, color)
              
//     error = SubFloats(error, dy)
//     SignedInt intError = FloatToInt(error)
//     var errorSign = intError.s
//     if(errorSign == true) // If error is less than 0, ie sign bit is 1
//     {
//         y = AddSignedInts(y, ystep)
//         error = AddFloats(error, dx)
//     }
//   }
// }


// void DrawLine(int x1,int y1,int x2,int y2, int color)
// {

//     // Bresenham's line algorithm
//     var suby2y1 = 0
//     if(y2>y1)
//         suby2y1=y2- y1
//     else
//         suby2y1=y1- y2
//     var subx2x1 = 0
//     if(x2>x1)
//         subx2x1=x2-x1
//     else
//         subx2x1=x1-x2

//     bool steep = suby2y1>subx2x1
//     if (steep) {
//         // std::swap(x1, y1);
//         var swapper = x1
//         x1 = y1
//         y1 = swapper
//         // std::swap(x2, y2);
//         var swapper = x2
//         x2 = y2
//         y2 = swapper
//     }

//     if (x1 > x2) {
//         // std::swap(x1, x2);
//         var swapper = x1
//         x1 = x2
//         x2 = swapper
//         // std::swap(y1, y2);
//         var swapper = y1
//         y1 = y2
//         y2 = swapper
//     }

// 	SignedInt dx = {s:0, val:0};
//     SignedInt dy = {s:0, val:0};
//     SignedInt p = {s:0, val:0};
// 	dx=SubSignedInts(Signed(x2), x1)
// 	dy=SubSignedInts(Signed(y2), y1)
//     SignedInt tmpDy = dy
//     tmpDy.val = tmpDy.val *2
// 	p = SubSignedInts(tmpDy, dx)
//     SignedInt tmpDyDx = SubSignedInts(dy, dx)
//     tmpDyDx.val = tmpDyDx.val *2
// 	while(x1 <= x2)
// 	{
// 		if(p.s == 1) // If less than 0
// 		{
// 			x1=x1+1
//             p = AddSignedInts(p, tmpDy)
// 		}
// 		else
// 		{
// 			x1=x1+1
// 			y1=y1+1
// 			p = AddSignedInts(p, tmpDyDx)
// 		}
// 		SetPixel(x1,y1,color)
// 	}
// }


// void DrawLine(int x1, int y1, int x2, int y2, int color) {

//     x1 = IntToFloat(x1)
//     y1 = IntToFloat(y1)
//     x2 = IntToFloat(x2)
//     y2 = IntToFloat(y2)

//     // Bresenham's line algorithm
//     var suby2y1 = SubFloats(y2, y1)
//     var subx2x1 = SubFloats(x2, x1)
//     bool steep = CompareFloats(fabs(suby2y1), fabs(subx2x1), '>')
//     if (steep) {
//         // std::swap(x1, y1);
//         var swapper = x1
//         x1 = y1
//         y1 = swapper
//         // std::swap(x2, y2);
//         var swapper = x2
//         x2 = y2
//         y2 = swapper
//     }

//     if (x1 > x2) {
//         // std::swap(x1, x2);
//         var swapper = x1
//         x1 = x2
//         x2 = swapper
//         // std::swap(y1, y2);
//         var swapper = y1
//         y1 = y2
//         y2 = swapper
//     }

//     Float16 dx = SubFloats(x2, x1)
//     Float16 dy = fabs(SubFloats(y2, y1))

//     Float16 half = {sign: 0, exponent:0b01110, fraction:0};
//     Float16 error = MultFloats(dx, half)

//     // int ystep = (y1 < y2) ? 1 : -1;
//     SignedInt ystep = {s:0, val:1};
//     if (y1 < y2){
//         ystep.s = 0
//     }
//     else{
//         ystep.s = 1
//     }

//     var y = FloatToUnsignedInt(y1)
//     SignedInt yTmp = {s:0, val:y};

//     var maxX = FloatToUnsignedInt(x2)

//     var flX1 = FloatToUnsignedInt(x1)

//     for (var x = flX1; x <= maxX; x++) {
//         if (steep) {
//             SetPixel(y, x, color)
//         }
//         else {
//             SetPixel(x, y, color)
//         }

//         // error -= dy
//         error = SubFloats(error, dy)
//         if (error.sign == 1) {
//             yTmp = AddSignedInts(yTmp, ystep)
//             y = yTmp.val
//             // error += dx
//             error = AddFloats(error, dx)
//         }
//     }
// }

// void DrawLine(int x0i, int y0i, int x1i, int y1i, int color){
//     SignedInt x0 = Signed(x0i)
//     SignedInt y0 = Signed(y0i)
//     SignedInt x1 = Signed(x1i)
//     SignedInt y1 = Signed(y1i)

//     // int x0,y0,x1,y1;
//     // cout<<"Enter the First Line Coordinates";
//     // cin>>x0>>y0;
//     // cout<<"Enter the Second Line Coordinates";
//     // cin>>x1>>y1;

//     // // Old C++
//     // int dx=x1-x0
//     // int dy=y1-y0
//     // int d=2*dy-dx
//     // int incrE=2*dy
//     // int incrNE=2*(dy-dx)
//     // int x=x0
//     // int y=y0

//     // dx=x1-x0
//     SignedInt dx = SubSignedInts(x1, x0)
//     // dy=y1-y0
//     SignedInt dy = SubSignedInts(y1,y0)
//     // d=2*dy-dx
//     SignedInt d = dy
//     d.val = (d.val*2) - dx
//     // incrE=2*dy
//     SignedInt incrE = dy
//     incrE.val = incrE.val * 2
//     // incrNE=2*(dy-dx)
//     SignedInt incrNE = SubSignedInts(dy, dx)
//     incrNE.val = incrNE.val * 2
//     // x=x0
//     SignedInt x = x0
//     // y=y0
//     SignedInt y = y0
    
//     SetPixel(x.val,y.val,color)

//     while(CompareSignedInts(x, x1, '<'))
//     {
//         if(d.s == 1)
//         {
//             d = AddSignedInts(d, incrE)
//             x +=1
//         }
//         else
//         {
//             d = AddSignedInts(d, incrNE)
//             x +=1
//             y +=1
//         }
//         SetPixel(x.val,y.val,color);
//     }
// }

// void Bresenham(int x1, int y1, int x2, int y2)
// {
//     int delta_x= Delta(x2 - x1)
//     // if x1 == x2, then it does not matter what we set here
//     signed char const ix((delta_x > 0) - (delta_x < 0));
//     delta_x = std::abs(delta_x) << 1;

//     int delta_y(y2 - y1);
//     // if y1 == y2, then it does not matter what we set here
//     signed char const iy((delta_y > 0) - (delta_y < 0));
//     delta_y = std::abs(delta_y) << 1;

//     plot(x1, y1);

//     if (delta_x >= delta_y)
//     {
//         // error may go below zero
//         int error(delta_y - (delta_x >> 1));
 
//         while (x1 != x2)
//         {
//             // reduce error, while taking into account the corner case of error == 0
//             if ((error > 0) || (!error && (ix > 0)))
//             {
//                 error -= delta_x;
//                 y1 += iy;
//             }
//             // else do nothing

//             error += delta_y;
//             x1 += ix;

//             plot(x1, y1);
//         }
//     }
//     else
//     {
//         // error may go below zero
//         int error(delta_x - (delta_y >> 1));

//         while (y1 != y2)
//         {
//             // reduce error, while taking into account the corner case of error == 0
//             if ((error > 0) || (!error && (iy > 0)))
//             {
//                 error -= delta_y;
//                 x1 += ix;
//             }
//             // else do nothing

//             error += delta_x;
//             y1 += iy;
 
//             plot(x1, y1);
//         }
//     }
// }

// void DrawLine(int x_starti, int y_starti, int x_endi, int y_endi, int c){
//     SignedInt x_start = Signed(x_starti)
//     SignedInt y_start = Signed(y_starti)
//     SignedInt x_end = Signed(x_endi)
//     SignedInt y_end = Signed(y_endi)
//     // """
//     // Implementation of Bresenham's line algorithm in Python. This will work for positive sloped lines
//     // with a gradient between 0 and 1 only. Also, x_start < x_end and y_start < y_end must be true.
//     // """
//     SignedInt dy = SubSignedInts(y_end, y_start)
//     SignedInt dx = SubSignedInts(x_end, x_start)
//     // # Note that the initial error does not start at zero!
//     SignedInt error = dy
//     error.val = error.val<<1
//     error.val = SubSignedInts(error.val, dx)

//     SignedInt dxX2 = dx
//     dxX2.val = (dx.val)<<1
//     SignedInt dyX2 = dy
//     dyX2.val = (dy.val)<<1

//     int y = y_starti
//     SetPixel(x_starti, y_starti, get_color(255, 0, 0))
//     SetPixel(x_endi, y_endi, get_color(0, 255, 0))
//     for (var x = x_starti; x < x_endi; x++){
//         SetPixel(x, y, 0b1111111111111111)
//         // print(f'x = {x}, y = {y}')
//         // # If error integer is > 0, we need to increment y and
//         // # update error
//         if (error.s == 0){
//             y += 1
//             // error -= dx<<1
//             error = SubSignedInts(error, dxX2)
//         }         
//         // error += dy<<1
//         error = AddSignedInts(error, dyX2)
//     }
//     SetPixel(x_starti, y_starti, get_color(255, 0, 0))
//     SetPixel(x_endi, y_endi, get_color(0, 255, 0))
// }

void DrawLine(Float16 x1, Float16 y1, Float16 x2, Float16 y2, int color)
{
    // Draw endpoints
    SetPixel(x1, y1, get_color(255, 0, 0))
    SetPixel(x2, y2, get_color(0, 255, 0))


	Float16 xdiff = SubFloats(x2, x1)
	Float16 ydiff = SubFloats(y2, y1)

	if((xdiff == FLOAT_ZERO) && (ydiff == FLOAT_ZERO)) { // If the starting and ending points are the same
		SetPixel(FloatToInt(x1), FloatToInt(y1), color);
		return 0
	}

	if(CompareFloats(fabs(xdiff), fabs(ydiff), '>')) {
		Float16 xmin = FLOAT_ZERO
        Float16 xmax = FLOAT_ZERO

		// set xmin to the lower x value given
		// and xmax to the higher value
		if(CompareFloats(x1, x2, '<')) {
			xmin = x1
			xmax = x2
		} else {
			xmin = x2
			xmax = x1
		}

		// draw line in terms of y slope
		Float16 slope = DivFloats(ydiff, xdiff)
        write_float(slope)
		// for(float x = xmin; x <= xmax; x += 1.0f) {
		// 	float y = y1 + ((x - x1) * slope);
		// 	Color color = color1 + ((color2 - color1) * ((x - x1) / xdiff));
		// 	SetPixel(x, y, color);
		// }
	} else {
		Float16 ymin = FLOAT_ZERO
        Float16 ymax = FLOAT_ZERO

		// set ymin to the lower y value given
		// and ymax to the higher value
		if(CompareFloats(y1, y2, '<')) {
			ymin = y1
			ymax = y2
		} else {
			ymin = y2
			ymax = y1
		}

		// draw line in terms of x slope
		Float16 slope = DivFloats(xdiff, ydiff)
        // write('s')
        SetPixel(100, 100, get_color(0, 0, 255))
		// // for(float y = ymin; y <= ymax; y += 1.0f) { // Original
		// // 	float x = x1 + ((y - y1) * slope);
		// // 	Color color = color1 + ((color2 - color1) * ((y - y1) / ydiff));
		// // 	SetPixel(x, y, color);
		// // }
        Float16 y = ymin
		while(CompareFloats(y, ymax, '<')) {
			Float16 x = AddFloats(x1, MultFloats(SubFloats(y, y1), slope));
			// Color color = color1 + ((color2 - color1) * ((y - y1) / ydiff));
			SetPixel(FloatToInt(x), FloatToInt(y), color);
            y = AddFloats(y, ONE)
		}
	}
}

// bool ptInTriangle(int px, int py, int p0x, int p0y, int p1x, int p1y, int p2x, int p2y)
// {
//     var dX = px-p2x
//     var dY = py-p2y
//     var dX21 = p2x-p1x
//     var dY12 = p1y-p2y
//     var D = dY12*(p0x-p2x) + dX21*(p0y-p2y)
//     var s = dY12*dX + dX21*dY
//     var t = (p2y-p0y)*dX + (p0x-p2x)*dY
//     if (D<0)
//         return s<=0 && t<=0 && s+t>=D
//     return s>=0 && t>=0 && s+t<=D
// }

// /* A utility function to calculate area of triangle formed by (x1, y1),
//    (x2, y2) and (x3, y3) */
// int area(int x1, int y1, int x2, int y2, int x3, int y3)
// {
//    return (x1*(y2-y3) + x2*(y3-y1)+ x3*(y1-y2))/2
// }

// bool isInside(int x, int y, int x1, int y1, int x2, int y2, int x3, int y3)
// {  
//    /* Calculate area of triangle ABC */
//    int A = area(x1, y1, x2, y2, x3, y3)
  
//    /* Calculate area of triangle PBC */ 
//    int A1 = area(x, y, x2, y2, x3, y3)
  
//    /* Calculate area of triangle PAC */ 
//    int A2 = area(x1, y1, x, y, x3, y3)
  
//    /* Calculate area of triangle PAB */  
//    int A3 = area(x1, y1, x2, y2, x, y)
    
//    /* Check if sum of A1, A2 and A3 is same as A */
//    var sum = A1 + A2 + A3
//    return (A >= sum-(10)&&A <= sum+(10));
// }

while (true) {
    // MouseInput input = expansionPorts[1];
    // var offset = input.y * 108 + input.x;

    // var xpos = input.x
    // var ypos = input.y
    DrawLine(10, 25, 70, 50, 0b1111111111111111)
    // if (input.left == 1) {
    //     screen[offset] = get_color(255, 255, 255);
    // }
    break
}

// struct MouseInput {
//     int y : 7;
//     int x : 7;
//     int left : 1;
//     int right : 1;
// };

// var chars = create_pointer(53546, 1)
// var offset = 0

// void write(int c) {
//     chars[offset] = c
//     offset++
// }

// void write_int(int value) {
//     var reverser = create_pointer(65530, 0)
//     var i = 0
//     for (var i = 0; i < 5; i++){
//         reverser[i] = 0
//     }
//     while (value > 0) {
//         var char = (value % 10) switch {
//             1 => '1',
//             2 => '2',
//             3 => '3',
//             4 => '4',
//             5 => '5',
//             6 => '6',
//             7 => '7',
//             8 => '8',
//             9 => '9',
//             _ => '0'
//         }

//         reverser[i] = char
//         value = value / 10
//         i += 1
//     }
//     for (var i = 0; i < 5; i++){
//         write(reverser[4-i])
//     }
// }

// write_int(area(3, 100, 54, 5, 100, 100))

// DrawLine(IntToFloat(10), IntToFloat(20), IntToFloat(60), IntToFloat(100), get_color(255, 255, 255))

// for (var x = 0; x < 108; x++) {
//     for (var y = 0; y < 108; y++) {
//         var screenOffset = (y * 108) + x
//         var pixel = 0
//         if(isInside(x, y, 3, 100, 54, 5, 100, 100)){
//             pixel = 65535
//         }
//         screen[screenOffset] = pixel
//         // // Delay
//         // for (var l = 0; l < 90 * 1; l++){
//         //     for (var o = 0; o < 1; o++){
//         //         // Do nothing  _(¦3」∠)_
//         //     }
//         // }
//     }
// }

while (true){

}


struct Float16 {
    int sign : 1
    int exponent : 5
    int fraction : 10
}

struct SignedInt {
    bool s : 1
    int val : 15
}
