
// import "float.yabal"

var floats = create_pointer<float16_t>(0x0, 1);
var signedInts = create_pointer<signedint_t>(0x1111, 1);

var screen = create_pointer(53871, 1)
// var cordicAngles = create_pointer(10000, 1)
var sinTable = create_pointer(10000, 1)
var pointsXY = create_pointer<Point>(11000, 1)
var pointsZ = create_pointer(12000, 1)
var RpointsXY = create_pointer<Point>(13000, 1)
var RpointsZ = create_pointer(14000, 1)

var expansionPorts = create_pointer(53500, 1)

var chars = create_pointer(53546, 1)

int offset = 0

var highlightColor = 0
var highlightOppositeColor = 0b1111111111111111

const float16_t FLOAT_ZERO = { sign : 0, exponent : 0, fraction : 0 };
const float16_t ONE = { sign : 0, exponent : 0b01111, fraction : 0 };
float16_t PI = { sign : 0, exponent : 0b10000, fraction : 0b1001001000 };
float16_t HALFPI = 0x3E48
float16_t PISQ = 0x48EE
float16_t ONE = { sign : 0, exponent : 0b01111, fraction : 0 };
float16_t ONETWENTYEIGHT = { sign : 0, exponent : 0b10110, fraction : 0 };
float16_t HALF = 0x3800

// https://gist.github.com/nowke/965fed0d5191bf373f1262be584207bb
void draw_line(int x1, int y1, int x2, int y2, int color) {
	signedint_t TWO = {s:0, val:2};

	signedint_t dx = {s:0, val:0};
	signedint_t dy = {s:0, val:0};
	// int i = 0
	signedint_t e = {s:0, val:0};

	signedint_t incx = {s:0, val:1};
	signedint_t incy = {s:0, val:1};
	signedint_t inc1 = {s:0, val:0};
	signedint_t inc2 = {s:0, val:0};

	signedint_t x = {s:0, val:x1};
	signedint_t y = {s:0, val:y1};

	// write_signed_int(x2)
	// write(',')
	// write_signed_int(x1)
	// write(' ')
	dx = Subsignedint_ts(x2,x)
	dy = Subsignedint_ts(y2,y)

	if (dx.s == 1) // If dx < 0
		dx.s = 0
	if (dy.s == 1)  // If dy < 0
		dy.s = 0

	if (x2 < x1)
		incx.s = 1

	if (y2 < y1)
		incy.s = 1

	// write_signed_int(dx)
	// write(',')
	// write_signed_int(dy)

	if (Comparesignedint_ts(dx, dy, '>')) {
		//SetPixel(x, y, color)
		e = Subsignedint_ts(dy, dx)
		e = Multsignedint_ts(e, TWO)
		inc1 = Subsignedint_ts(dy, dx)
		inc1 = Multsignedint_ts(inc1, TWO)
		inc2 = Multsignedint_ts(dy, TWO)
		var maxval = dx.val
		for (var i=0; i<maxval; i++) {
			if (e.s == 0 || ((e.s == 1) && (e.val == 0))) { // if  e >= 0
				// y += incy
				y = Addsignedint_ts(y, incy)
				// e += inc1
				e = Addsignedint_ts(e, inc1)
				// newline()
				// write_signed_int(y)
			}
			else{
				// e += inc2
				e = Addsignedint_ts(e, inc2)
			}
			// x += incx
			x = Addsignedint_ts(x, incx)
            if(x.val>=107||y.val>107) // Don't draw pixels out of range
                continue
			SetPixel(x, y, color)
		}

	} else {
		//SetPixel(x, y, color)
		// e = 2*dx-dy
		e = Multsignedint_ts(dx, TWO)
		e = Subsignedint_ts(e, dy)
		// inc1 = 2*(dx-dy)
		inc1 = Subsignedint_ts(dx, dy)
		inc1 = Multsignedint_ts(inc1, TWO)
		// inc2 = 2*dx
		inc2 = Multsignedint_ts(dx, TWO)
		var maxval = dy.val
		for (var i = 0; i < maxval; i++) {
			if (e.s == 0 || ((e.s == 1) && (e.val == 0))) { // if  e >= 0
				// x += incx
				x = Addsignedint_ts(x, incx)
				// e += inc1
				e = Addsignedint_ts(e, inc1)
				// newline()
				// write_signed_int(x)
			}
			else{
				// e += inc2
				e = Addsignedint_ts(e, inc2)
			}
			// y += incy
			y = Addsignedint_ts(y, incy)
			int xval = x.val
			int yval = y.val
            if(xval>=107||yval>107) // Don't draw pixels out of range
                continue
			SetPixel(xval, yval, color)
		}
	}
	// SetPixel(x1, y1, get_color(255, 0, 0))
	// SetPixel(x2, y2, get_color(0, 255, 0))
}

void DrawWireTriangle(int x0, int y0,int x1, int y1,int x2, int y2, int color){
	draw_line(x0, y0, x1, y1, color)
	draw_line(x1, y1, x2, y2, color)
	draw_line(x0, y0, x2, y2, color)
}

// // Not good method, change in future
// void DrawFilledTriangle(int x0, int y0,int x1, int y1,int x2, int y2, int color){
//     DrawWireTriangle(x0, y0, x1, y1, x2, y2, ~color)
//     // Get center of triangle
//     int centroidX = (x0+x1+x2)/3
//     int centroidY = (y0+y1+y2)/3
//     // Draw center pixel
//     SetPixel(centroidX, centroidY, color)
//     SetPixel((centroidX+x0)/2, (centroidY+y0)/2, color)
//     SetPixel((centroidX+x1)/2, (centroidY+y1)/2, color)
//     SetPixel((centroidX+x2)/2, (centroidY+y2)/2, color)
//     // SetPixel(centroidX, centroidY, color)

//     int found = 11
//     while(found > 10){
//         found = 0
//         for(var y=1; y<107; y++){
//             for(var x=1; x<107; x++){
//                 if(GetPixel(x, y) == color){ // If current center pixel is the draw color, check neighbors
//                     if(GetPixel(x-1, y) != ~color && GetPixel(x-1, y) != color){
//                         SetPixel(x-1, y, color)
//                         found += 1
//                     }
//                     if(GetPixel(x, y-1) != ~color && GetPixel(x, y-1) != color){
//                         SetPixel(x, y-1, color)
//                         found += 1
//                     }
//                     if(GetPixel(x+1, y) != ~color && GetPixel(x+1, y) != color){
//                         SetPixel(x+1, y, color)
//                         found += 1
//                     }
//                     if(GetPixel(x, y+1) != ~color && GetPixel(x, y+1) != color){
//                         SetPixel(x, y+1, color)
//                         found += 1
//                     }
//                 }
//             }
//         }
//         for(var y=106; y>0; y--){
//             for(var x=106; x>0; x--){
//                 if(GetPixel(x, y) == color){ // If current center pixel is the draw color, check neighbors
//                     if(GetPixel(x-1, y) != ~color && GetPixel(x-1, y) != color){
//                         SetPixel(x-1, y, color)
//                         found += 1
//                     }
//                     if(GetPixel(x, y-1) != ~color && GetPixel(x, y-1) != color){
//                         SetPixel(x, y-1, color)
//                         found += 1
//                     }
//                     if(GetPixel(x+1, y) != ~color && GetPixel(x+1, y) != color){
//                         SetPixel(x+1, y, color)
//                         found += 1
//                     }
//                     if(GetPixel(x, y+1) != ~color && GetPixel(x, y+1) != color){
//                         SetPixel(x, y+1, color)
//                         found += 1
//                     }
//                 }
//             }
//         }
//     }
// }

void DrawFilledCircle(int xCenter, int yCenter, int radius, int color){
	int radiusSquared = radius*radius

    signedint_t xOrig = NegativeSigned(radius)
    signedint_t x = xOrig
    signedint_t y = NegativeSigned(radius)

    var rad1 = radius+1
    var newX = 0
    var newY = 0

    while(y.s == 1 || y.val< rad1){
        while(x.s == 1 || x.val< rad1){
            newX = xCenter+SignedToTwosComp(x)
            newY = yCenter+SignedToTwosComp(y)
            // Make sure pixel is inside screen, otherwise don't render it.
            if(newX>=107||newY>=107){
                x = Addsignedint_ts(x, 1)
                continue
            }

            if(Addsignedint_ts(x.val*x.val,y.val*y.val) <= radiusSquared+radius){ // Calculate distance between point and center of circle. If lessthan or equal to radius, color pixel.
                SetPixel(newX, newY, color)
            }

            // write('x')
            x = Addsignedint_ts(x, 1)
        }
        x = xOrig
        y = Addsignedint_ts(y, 1)
    }

}

void DrawWireCircle(int xCenter, int yCenter, int radius, int color){
	int radiusSquared = radius*radius

    signedint_t xOrig = NegativeSigned(radius)
    signedint_t x = xOrig
    signedint_t y = xOrig

    var rad1 = radius+1
    var newX = 0
    var newY = 0

    while(y.s == 1 || y.val< rad1){
        while(x.s == 1 || x.val< rad1){
            newX = xCenter+SignedToTwosComp(x)
            newY = yCenter+SignedToTwosComp(y)
            // Make sure pixel is inside screen, otherwise don't render it.
            if(newX>=107||newY>=107){
                x = Addsignedint_ts(x, 1)
                continue
            }

            signedint_t tot = Addsignedint_ts(x.val*x.val,y.val*y.val)
            if((tot.val >= radiusSquared-radius) && (tot.val <= radiusSquared+radius)){ // Calculate distance between point and center of circle. If lessthan or equal to radius, color pixel.
                SetPixel(newX, newY, color)
            }

            // write('x')
            x = Addsignedint_ts(x, 1)
        }
        x = xOrig
        y = Addsignedint_ts(y, 1)
    }


}


// bool ptInTriangle(int translatedX, int translatedY, int p0x, int p0y, int p1x, int p1y, int p2x, int p2y)
// {
//     var dX = translatedX-p2x
//     var dY = translatedY-p2y
//     var dX21 = p2x-p1x
//     var dY12 = p1y-p2y
//     var D = dY12*(p0x-p2x) + dX21*(p0y-p2y)
//     var s = dY12*dX + dX21*dY
//     var t = (p2y-p0y)*dX + (p0x-p2x)*dY
//     if (D<0)
//         return s<=0 && t<=0 && s+t>=D
//     return s>=0 && t>=0 && s+t<=D
// }

// /* A utility function to calculate area of triangle formed by (x1, y1),
//    (x2, y2) and (x3, y3) */
// int area(int x1, int y1, int x2, int y2, int x3, int y3)
// {
// //    return (x1*SubTosignedint_t(y2,y3) + x2*SubTosignedint_t(y3,y1)+ x3*SubTosignedint_t(y1,y2))/2
//     signedint_t y2y3Dif = SubTosignedint_t(y2, y3)
//     signedint_t y3y1Dif = SubTosignedint_t(y3, y1)
//     signedint_t y1y2Dif = SubTosignedint_t(y1, y2)
//     write_signed_int(SubTosignedint_t(x1, y3))
//     write(',')
//     // write_signed_int(y2)
//     // write(',')
//     // write_signed_int(y1y2Dif)
//     // write(',')
//     //return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)
//     var outvar = ((Addsignedint_ts(Addsignedint_ts(Multsignedint_ts(x1, SubTosignedint_t(y2, y3)), Multsignedint_ts(x2, SubTosignedint_t(y3, y1))), Multsignedint_ts(x3, SubTosignedint_t(y1, y2))))&0b111111111111111)/2
//     // write('o')
//     // write(':')
//     write_int(outvar)
//     return outvar
// }

// bool isInside(int x, int y, int x1, int y1, int x2, int y2, int x3, int y3)
// {
// //    write('o')
//    /* Calculate area of triangle ABC */
//    var A = area(x1, y1, x2, y2, x3, y3)
// //    write_int(y1)

//    /* Calculate area of triangle PBC */
//    var A1 = area(x, y, x2, y2, x3, y3)

//    /* Calculate area of triangle PAC */
//    var A2 = area(x1, y1, x, y, x3, y3)

//    /* Calculate area of triangle PAB */
//    var A3 = area(x1, y1, x2, y2, x, y)

//    /* Check if sum of A1, A2 and A3 is same as A */
//    var sum = A1 + A2 + A3
//    write_int(sum)
//    return ((A >= sum-100)&&(A <= sum+100))
// }

var lfsr = 0b1011101011101000;
int lfsr()
{
    var bit = 0

	bit = ((lfsr >> 1) ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 7)) & 1
	lfsr = (lfsr >> 1) | (bit << 15)

    return bit;
}
int rand(int bits)
{
    // var start_state = 0b1100101011011100
    var out = 0
	int count = 0
    // var period = 0

    while(count < bits)
    {
		out = out << 1
		out = out | lfsr()
		count += 1
    }

    return out;
}

// Init sine table
sinTable[0] = 0;
sinTable[1] = 2;
sinTable[2] = 4;
sinTable[3] = 6;
sinTable[4] = 8;
sinTable[5] = 11;
sinTable[6] = 13;
sinTable[7] = 15;
sinTable[8] = 17;
sinTable[9] = 20;
sinTable[10] = 22;
sinTable[11] = 24;
sinTable[12] = 26;
sinTable[13] = 28;
sinTable[14] = 30;
sinTable[15] = 33;
sinTable[16] = 35;
sinTable[17] = 37;
sinTable[18] = 39;
sinTable[19] = 41;
sinTable[20] = 43;
sinTable[21] = 45;
sinTable[22] = 47;
sinTable[23] = 50;
sinTable[24] = 52;
sinTable[25] = 54;
sinTable[26] = 56;
sinTable[27] = 58;
sinTable[28] = 60;
sinTable[29] = 62;
sinTable[30] = 63;
sinTable[31] = 65;
sinTable[32] = 67;
sinTable[33] = 69;
sinTable[34] = 71;
sinTable[35] = 73;
sinTable[36] = 75;
sinTable[37] = 77;
sinTable[38] = 78;
sinTable[39] = 80;
sinTable[40] = 82;
sinTable[41] = 83;
sinTable[42] = 85;
sinTable[43] = 87;
sinTable[44] = 88;
sinTable[45] = 90;
sinTable[46] = 92;
sinTable[47] = 93;
sinTable[48] = 95;
sinTable[49] = 96;
sinTable[50] = 98;
sinTable[51] = 99;
sinTable[52] = 100;
sinTable[53] = 102;
sinTable[54] = 103;
sinTable[55] = 104;
sinTable[56] = 106;
sinTable[57] = 107;
sinTable[58] = 108;
sinTable[59] = 109;
sinTable[60] = 110;
sinTable[61] = 111;
sinTable[62] = 113;
sinTable[63] = 114;
sinTable[64] = 115;
sinTable[65] = 116;
sinTable[66] = 116;
sinTable[67] = 117;
sinTable[68] = 118;
sinTable[69] = 119;
sinTable[70] = 120;
sinTable[71] = 121;
sinTable[72] = 121;
sinTable[73] = 122;
sinTable[74] = 123;
sinTable[75] = 123;
sinTable[76] = 124;
sinTable[77] = 124;
sinTable[78] = 125;
sinTable[79] = 125;
sinTable[80] = 126;
sinTable[81] = 126;
sinTable[82] = 126;
sinTable[83] = 127;
sinTable[84] = 127;
sinTable[85] = 127;
sinTable[86] = 127;
sinTable[87] = 127;
sinTable[88] = 127;
sinTable[89] = 127;


signedint_t sin(int x){
    x+=360;

    var loopTimes = 0;

    while(x>179){
        x -= 180

        loopTimes += 1;
    }

    if(x > 89){
        x = 90 - (x-89);
    }

    int outSinVal = sinTable[x];
    signedint_t outVal = {s:0, val:(sinTable[x])}

    if(loopTimes % 2 == 0){ // should be negative
        outVal.s = 1
        return outVal
    }
    // else, positive
    return outVal

    // int willAdd = 128
    // if(loopTimes % 2 == 0){
    //     return willAdd-sinTable[x]
    // }
    // return sinTable[x] + willAdd

    //int out = sinTable[x]
    //return (sinTable[x] + willAdd)
    //return sinTable[x] + willAdd
}

signedint_t cos(int x){
    x+=360;
    
    var loopTimes = 0;

    x -= 90 // Offset for cos input

    return sin(x)
}

// int lastY = 0
// for(int x = 1; x < 106; x++){
    
//     int xCoord = x*10

//     signedint_t yCoord = sin(xCoord)
//     yCoord = yCoord + 128
//     yCoord = yCoord / 9
//     // if(loopTimes % 2 == 0){
//     //     yCoord = 40-yCoord/9
//     // }
//     // else{
//     //     yCoord = yCoord/9+40
//     // }
//     if(lastY == 0)
//         lastY = yCoord
//     draw_line(x, yCoord, x-1, lastY, 0b1111111111100011)
//     //SetPixel(x, yCoord/3, 0b1111111111100011)
//     lastY = yCoord
// }

// lastY = 0
// for(int x = 1; x < 106; x++){
    
//     int xCoord = x*10
//     bool topOfCurve = false

//     int yCoord = cos(xCoord)
//     yCoord = yCoord / 9
//     // if(loopTimes % 2 == 0){
//     //     yCoord = 40-yCoord/9
//     // }
//     // else{
//     //     yCoord = yCoord/9+40
//     // }
//     if(lastY == 0)
//         lastY = yCoord
//     draw_line(x, yCoord, x-1, lastY, 0b00000000011011)
//     //SetPixel(x, yCoord/3, 0b1111111111100011)
//     lastY = yCoord
// }

// float16_t ss = qSin(90)
// // write('v')
// write_float(ss)

int _RotatedX = 1;
int _RotatedY = 1;
int _RotatedZ = 1;
void RotatePoint(int index, int degrees){
    Point value = pointsXY[index]

    signedint_t inX = value.x
    signedint_t inY = value.y

    // Calculate sine and cosine of the angle using integer math
    int angle = degrees
    signedint_t sinVal = sin(angle);
    signedint_t cosVal = cos(angle);

    // Translate point to the origin
    signedint_t offset = {s:0, val:54};
    signedint_t translatedX;
    signedint_t translatedY;
    translatedX = inX - offset;
    translatedY = inY - offset;

    // Perform rotation using integer math
    signedint_t rotatedX = (translatedX * cosVal - translatedY * sinVal)/128;
    signedint_t rotatedY = (translatedX * sinVal + translatedY * cosVal)/128;

    // Translate point back to its original position
    _RotatedX = rotatedX+offset;
    _RotatedY = rotatedY+offset;

    //_RotatedX = (vx<<8)|vy;
}

void RotatePoint3D(int index, int xRotate, int yRotate, int zRotate){
    Point xy = pointsXY[index]
    int zz = pointsZ[index]

    signedint_t inX = xy.x
    signedint_t inY = xy.y
    signedint_t inZ = zz

    // Calculate sine and cosine of the angle using integer math
    signedint_t sinX = sin(xRotate);
    signedint_t cosX = cos(xRotate);
    signedint_t sinY = sin(yRotate);
    signedint_t cosY = cos(yRotate);
    signedint_t sinZ = sin(zRotate);
    signedint_t cosZ = cos(zRotate);

    // Translate point to the origin
    signedint_t offset = {s:0, val:54};
    signedint_t translatedX = inX - offset;
    signedint_t translatedY = inY - offset;
    signedint_t translatedZ = inZ - offset;
    
    signedint_t Axx = cosX*cosY;
    signedint_t Axy = (cosX*sinY*sinZ) - (sinX*cosZ);
    signedint_t Axz = (cosX*sinY*cosZ) + (sinX*sinZ);

    signedint_t Ayx = sinX*cosY;
    signedint_t Ayy = sinX*sinY*sinZ + cosX*cosZ;
    signedint_t Ayz = sinX*sinY*cosZ - cosX*sinZ;

    signedint_t Azx = -sinY;
    signedint_t Azy = cosY*sinZ;
    signedint_t Azz = cosY*cosZ;
    
    _RotatedX = (Axx*translatedX + Axy*translatedY + Axz*translatedZ);
    _RotatedY = (Ayx*translatedX + Ayy*translatedY + Ayz*translatedZ);
    _RotatedZ = (Azx*translatedX + Azy*translatedY + Azz*translatedZ);
    
    _RotatedX = (_RotatedX/1024)+offset;
    _RotatedY = (_RotatedY/1024)+offset;
    _RotatedZ = (_RotatedZ/1024)+offset;

    //// Perform rotation using integer math
    //signedint_t rotatedX = (translatedX * cosVal - translatedY * sinVal)/128;
    //signedint_t rotatedY = (translatedX * sinVal + translatedY * cosVal)/128;

    //// Translate point back to its original position
    //int vx = rotatedX+offset;
    //int vy = rotatedY+offset;

    //_RotatedX = (vx<<8)|vy;
}


int counter = 0;

    

// Front of cube
pointsXY[0] = {x : 27, y : 27};
pointsZ[0] = 27;
pointsXY[1] = {x : 81, y : 27};
pointsZ[1] = 27;
pointsXY[2] = {x : 81, y : 81};
pointsZ[2] = 27;
pointsXY[3] = {x : 27, y : 81};
pointsZ[3] = 27;
// Back of cube
pointsXY[4] = {x : 27, y : 27};
pointsZ[4] = 81;
pointsXY[5] = {x : 81, y : 27};
pointsZ[5] = 81;
pointsXY[6] = {x : 81, y : 81};
pointsZ[6] = 81;
pointsXY[7] = {x : 27, y : 81};
pointsZ[7] = 81;
    

// // Front of cube
// pointsXY[0] = (27 << 8) |  27;
// pointsZ[0] = 1;
// pointsXY[1] = (81 << 8) |  27;
// pointsZ[1] = 1;
// pointsXY[2] = (81 << 8) |  81;
// pointsZ[2] = 1;
// pointsXY[3] = (27 << 8) |  81;
// pointsZ[3] = 1;
// // Back of cube
// pointsXY[4] = (27 << 8) |  27;
// pointsZ[4] = 2;
// pointsXY[5] = (81 << 8) |  27;
// pointsZ[5] = 2;
// pointsXY[6] = (81 << 8) |  81;
// pointsZ[6] = 2;
// pointsXY[7] = (27 << 8) |  81;
// pointsZ[7] = 2;

//write_binary(pointsXY[5]);

while (true) {
    counter += 1;
    
// for(int i = 0; i < 400; i++){
// for(int f = 0; f < 10; f++){

// }
// }


    // iterate all points, and rotate them.
    for(int i = 0; i < 8; i++){
        RotatePoint3D(i, counter, 0, 0)
        RpointsXY[i] = ((_RotatedX<<8) | _RotatedY);
        RpointsZ[i] = 1
        // int rX = (_RotatedX & 0b1111111100000000)>>8
        // int rY = _RotatedX & 0b11111111
        //Point rPoi = RpointsXY[i]
        //SetPixel(rPoi.x, rPoi.y, 0b111111)
    }
    Point rPoi1 = RpointsXY[0] / RpointsZ[0]
    Point rPoi2 = RpointsXY[1] / RpointsZ[0]
    Point rPoi3 = RpointsXY[2] / RpointsZ[0]
    Point rPoi4 = RpointsXY[3] / RpointsZ[0]
    DrawWireTriangle(rPoi1.x, rPoi1.y, rPoi2.x, rPoi2.y, rPoi3.x, rPoi3.y, 0b111110000011111);
    DrawWireTriangle(rPoi1.x, rPoi1.y, rPoi3.x, rPoi3.y, rPoi4.x, rPoi4.y, 0b000001111111111);
    DrawFilledCircle(rPoi1.x, rPoi1.y, 2, 0b000000000011111)
    DrawFilledCircle(rPoi2.x, rPoi2.y, 2, 0b111110000000000)
    DrawFilledCircle(rPoi3.x, rPoi3.y, 2, 0b111111111100000)
    DrawFilledCircle(rPoi4.x, rPoi4.y, 2, 0b000001111100000)

    // DrawWireTriangle(v0x, v0y, v2x, v2y, v3x, v3y, color);

    // // iterate rotated points, and draw their triangles
    // for(int i = 0; i < 8; i++){
    //     RotatePoint(i, 10)
    //     RpointsXY[i] = _RotatedX
    //     int rX = (_RotatedX & 0b1111111100000000)>>8
    //     int rY = _RotatedX & 0b11111111
    //     SetPixel(rX, rY, 0b111111)
    // }




    // RotatePoint(0, counter)
    // int rX = (_RotatedX & 0b1111111100000000)>>8
    // int rY = _RotatedX & 0b11111111
    // SetPixel(rX, rY, 0b111111)

    
    // RotatePoint(4, counter)
    // int rX = (_RotatedX & 0b1111111100000000)>>8
    // int rY = _RotatedX & 0b11111111
    // SetPixel(rX, rY, 0b11111100000)
    //SetPixel(v0x, v0y, 0b11111)


    // write_int(v1x)
    // newline()
    // write_int(v1y)
    // newline()

    // // translate point back to origin:
    // p.x -= cx;
    // p.y -= cy;

    // // rotate point
    // int xnew = v1x * c - v1y * s;
    // int ynew = v1x * s + v1y * c;

    
    
    // // Back
    // DrawWireTriangle(v4x, v4y, v5x, v5y, v7x, v7y, color); // Front right
    // DrawWireTriangle(v5x, v5y, v6x, v6y, v7x, v7y, color); // Front left
    
    // if(choice == 0)
    //     DrawWireCircle(x0, y0, r, color)
    // else if(choice == 1)
         //DrawWireTriangle(x0, y0, x1, y1, x2, y2, color)
    // else if(choice == 2)
    //    DrawFilledCircle(x0, y0, r, color)
    // else if(choice == 3)
        //DrawFilledTriangle(x0, y0, x1, y1, x2, y2, color)
	// break
    asm{
        VBUF
    };
    
    // DrawWireTriangle(rPoi1.x, rPoi1.y, rPoi2.x, rPoi2.y, rPoi3.x, rPoi3.y, 0);
    // DrawWireTriangle(rPoi1.x, rPoi1.y, rPoi3.x, rPoi3.y, rPoi4.x, rPoi4.y, 0);
    // // // Black out screen
    // color = 0
    // //int color = 23422;
    // DrawWireTriangle(v0x, v0y, v1x, v1y, v2x, v2y, color)
    // DrawWireTriangle(v0x, v0y, v2x, v2y, v3x, v3y, color)
    for(int x = 0; x < (108*108); x++)
        screen[x] = 0;
}

// struct MouseInput {
//     int y : 7;
//     int x : 7;
//     int left : 1;
//     int right : 1;
// };

// var chars = create_pointer(53546, 1)
// var offset = 0

// void write(int c) {
//     chars[offset] = c
//     offset++
// }

// void write_int(int value) {
//     var reverser = create_pointer(65530, 0)
//     var i = 0
//     for (var i = 0; i < 5; i++){
//         reverser[i] = 0
//     }
//     while (value > 0) {
//         var char = (value % 10) switch {
//             1 => '1',
//             2 => '2',
//             3 => '3',
//             4 => '4',
//             5 => '5',
//             6 => '6',
//             7 => '7',
//             8 => '8',
//             9 => '9',
//             _ => '0'
//         }

//         reverser[i] = char
//         value = value / 10
//         i += 1
//     }
//     for (var i = 0; i < 5; i++){
//         write(reverser[4-i])
//     }
// }

// write_int(area(3, 100, 54, 5, 100, 100))

// DrawLine(IntToFloat(10), IntToFloat(20), IntToFloat(60), IntToFloat(100), get_color(255, 255, 255))

// for (var x = 0; x < 108; x++) {
//     for (var y = 0; y < 108; y++) {
//         var r = rand(5)
//         SetPixel(x, y, (r<<5)|(r<<10)|r)
//         // // Delay
//         // for (var l = 0; l < 90 * 1; l++){
//         //     for (var o = 0; o < 1; o++){
//         //         // Do nothing  _(¦3」∠)_
//         //     }
//         // }
//     }
// }

// newline()
// signedint_t a = {s:0, val:70};
// signedint_t b = {s:1, val:10};
// var outint = Addsignedint_ts(a, b)
// write_signed_int(a)
// write('+')
// write_signed_int(b)
// write('=')
// write_signed_int(outint)


while (true){

}



//////////////////////////////////////////
//  This is all float and writing code: //
//////////////////////////////////////////


// var floats = create_pointer<float16_t>(0x0, 1);
// var signedInts = create_pointer<signedint_t>(0x1111, 1);
// var screen = create_pointer(53871, 1)
// var charMem = create_pointer(53546, 1)



inline int get_color(int r, int g, int b) {
    return (r / 8 << 10) + (g / 8 << 5) + (b / 8);
}

int ClampInt(int x, int min, int max){
    if(x<min)
        return min
    else if(x>max)
        return max

    return x
}

// Function for drawing a single pixel to the screen
void SetPixel(int x, int y, int color){
    var screenOffset = (ClampInt(y, 0, 107) * 108) + ClampInt(x, 0, 107)
    screen[screenOffset] = color
}

// Function for getting a single pixel color from video memory
int GetPixel(int x, int y){
    var screenOffset = (ClampInt(y, 0, 107) * 108) + ClampInt(x, 0, 107)
    return screen[screenOffset]
}

void ChangeHighlightColor(int r, int g, int b){
    highlightColor = get_color(r, g, b)
    highlightOppositeColor = get_color(256-r, 256-g, 256-b)
}

void write(int c) {
    chars[offset] = c

    // Draw highlight behind character
    var pixOffsetY = (offset/18)*6
    var pixOffsetX = ((offset*6)%108)
    for (var x = 0; x < 6; x++) {
        for (var y = 0; y < 6; y++) {
            var pixel = highlightColor
            SetPixel(pixOffsetX+x, pixOffsetY+y, pixel)
        }
    }

    // Increment location offset by 1
    offset++
}

// Get the absolute value of a float value
float16_t fabs(float16_t f){
    float16_t outFloat = {sign:0, exponent:0, fraction:0};
    outFloat.exponent = f.exponent
    outFloat.fraction = f.fraction
    return outFloat
}

signedint_t IntTosignedint_t(int x){
    signedint_t o = {s:0, val:x};
    return o
}

int SignedToTwosComp(signedint_t x){
    int out = x.val
    if(x.s){
        out = Negative(out)
    }
    return out
}

// void writeStr(int s) {
//     var size = sizeof(s)
//     for (var i = 0; i < size; i++) {
//         write(s[i])
//     }
// }

void newline(){
    offset = offset / 18 * 18 + 18
}

void write_int(int value) {
    var reverser = create_pointer(65530, 0)
    var i = 0
    for (var o = 0; o < 5; o++){
        reverser[o] = 0
    }
    while (value > 0) {
        var char = (value % 10) switch {
            1 => '1',
            2 => '2',
            3 => '3',
            4 => '4',
            5 => '5',
            6 => '6',
            7 => '7',
            8 => '8',
            9 => '9',
            _ => '0'
        }

        reverser[i] = char
        value = value / 10
        i += 1
    }
    bool atFirst = false
    for (var o = 0; o < 5; o++){
        // If the first non-zero number has finally been found, start writing number
        if(reverser[4-o] != 0)
            atFirst = true
        // Otherwise it is just a trailing zero, so skip
        else if(atFirst==false)
            continue
        write(reverser[4-o])
    }
}

void write_binary(int value) {
    var reverser = create_pointer(65519, 0)
    var i = 0
    for (var i = 0; i < 16; i++){
        reverser[i] = 0
    }
    while (value > 0) {
        var char = (value & 1) switch {
            1 => '1',
            _ => '0'
        }

        reverser[15-i] = char
        value = value >> 1
        i += 1
    }
    for (var i = 0; i < 16; i++){
        write(reverser[i])
    }
}

void write_float(float16_t f) {
    write('e')
    write(':')
    var exp = f.exponent
    write_binary(f.exponent)
    write('f')
    write(':')
    var frac = f.fraction
    write_binary(f.fraction)
}

void write_signed_int(signedint_t i) {
    if(i.s == true) // If negative, print `-`
        write('-')
    int v = i.val
    write_int(v)
}

int TruncateTrailingZeros(int x){
    var o = x
    for (var i = 0; i < 16; i++){
        // If the last digit is 1, then stop shifting
        if((o & 1) == 1)
            break
        // Otherwise shift again
        o = o >> 1
    }
    return o
}

// void write_float(float16_t value) {
//     if (value.sign == 1) {
//         write('-')
//     }

//     write_int(value.exponent)
//     write('.')
//     write_int(value.fraction)
// }


// Returns true if values a and b are within +-range of eachother
bool WithinRange(signedint_t aI, signedint_t bI, int range){
    var a = aI.val
    var b = bI.val
    if(a > b){
        if((a-b)<=range){
            // write_int(a-b)
            return true
        }
        else{
            return false
        }
    }
    else if(a < b){
        if((b-a)<=range){
            // write_int(b-a)
            return true
        }
        else{
            return false
        }
    }
    return true
}

int Delta(int a, int b){
    if(a > b)
        return a - b
    else if(a < b)
        return b - a

    return 0
}

// Temporary bitwise not ~ operator function, sinZe currently that operator
// is broken and only returns 0 unless used like this:
int NOT(int x){
    return ~x&0b1111111111111111
}

// Convert integer to it's negative value in twos complement
int Negative(int x){
    return NOT(x) + 1
}

inline int XOR(int a, int b){
    return (a|b)&(NOT(a&b))
}


int get_shift_amnt(int man, int exp){
    return 10-exp
}

// string DecimalToBinaryString(int a)
// {
//     uint b = (uint)a
//     string binary = ""
//     uint mask = 0x80000000u
//     while (mask > 0)
//     {
//         binary += ((b & mask) == 0) ? '0' : '1'
//         mask >>= 1
//     }
//     return binary
// }

// Kindof inefficient square root method
int sqrt(int x){
	int counter=1
	int sqroot=1
	while(sqroot <= x)
	{
		counter += 1
		sqroot = counter*counter
	}
	return counter - 1
}

// Returns the integer base raised to the power integer exponent
int pow(signedint_t base, signedint_t exponent){
    var calculated = base
    var finalSign = 0
    if(base.s)
        finalSign = !(exponent.val%2==0)
    // If the exponent is negative, we divide each time instead of multiply
    if(exponent.s == 1){
        for (var i = 1; i < exponent.val; i++){
            calculated = calculated / base
        }
    }
    // Otherwise it is normal multiplication exponent
    else {
        for (var i = 1; i < exponent.val; i++){
            calculated = calculated * base
        }
    }
    return calculated|(finalSign<<15)
}

// Adjust a float so that the 11th bit in the mantissa is 1, the whole number
float16_t normalizeFloat(int fraction, int exponent){
    var frac = fraction
    var exp = exponent
    // If the 11th digit is already the whole number 1
    if((frac & 0b1111100000000000) == 0 && (frac & 0b10000000000) == 0b10000000000){
        exp += 1
    }
    else{
        // If leftmost digit is further than mantissa max of 10, then shift right
        for (var j = 0; j < 10; j++){
            // If the left has no 1s, then stop shifting
            if((frac & 0b1111100000000000) == 0)
                break
            // Otherwise shift again
            frac = frac >> 1
            exp += 1
        }
        // Shift left until 11th digit is 1
        for (var i = 0; i < 12; i++){
            // If the left digit is 1, then stop shifting
            if((frac & 0b10000000000) == 0b10000000000)
                break
            // Otherwise shift again
            frac = frac << 1
            exp -= 1
        }
    }
    frac = frac&0b1111111111
    float16_t outFloat = { sign : 0, exponent : exp, fraction : frac };
    return outFloat
}

int deNormalizeFraction(int f, int exp){
    bool sn = (10-exp>60000)
    var vl = 10-exp
    // signedint_t powNum = { s : 0, val : 0 };
    if (sn){
        vl = 65535-(10-exp)
        // powNum.s = 1
    }
    // powNum.val = vl


    // return (f * pow(2, powNum))
    // If negative
    if(sn == 1){
        return f<<vl
    }
    // Otherwise shift normal way
    else{
        return f>>vl
    }
}

signedint_t Addsignedint_ts(signedint_t a, signedint_t b){
    signedint_t outInt = {s: 0, val:0};

    // If the signs are the same, just add and return that same sign
    if(a.s == b.s){
        outInt.s = a.s
        outInt.val = (a.val+b.val)
    }
    // Else if the signs are different and a is negative while b is positive, subtract a from b (b-a)
    else if(a.s == 1){
        // If the value of A is bigger than the value of B, then that means subtracting will make B negative
        if(a.val > b.val){
            outInt.s = 1
            outInt.val = a.val-b.val
        }
        else{
            outInt.val = b.val-a.val
        }

        // outInt.val = Delta(a.val,b.val)
    }
    // Else if the signs are different and b is negative while a is positive, subtract b from a (a-b)
    else if(b.s == 1){
        // If the value of B is bigger than the value of A, then that means subtracting will make A negative
        if(b.val > a.val){
            outInt.s = 1
            outInt.val = b.val-a.val
        }
        else{
            outInt.val = a.val-b.val
        }

        // outInt.val = Delta(b.val,a.val)
    }

    return outInt
}


// signedint_t a = {s:1, val:13};
// signedint_t b = {s:1, val:14};
// var outint = Multsignedint_ts(a, b)
// write_signed_int(a)
// write('*')
// write_signed_int(b)
// write('=')
// write_signed_int(outint)

// signedint_t a = {s:1, val:13};
// signedint_t b = {s:1, val:14};
// var comp = '>'
// var outint = Comparesignedint_ts(a, b, comp)
// write_signed_int(a)
// write('>')
// write_signed_int(b)
// write('=')
// if(outint){
//     write('t')
//     write('r')
//     write('u')
//     write('e')
// }
// else{
//     write('f')
//     write('a')
//     write('l')
//     write('s')
//     write('e')
// }


signedint_t Subsignedint_ts(signedint_t a, signedint_t b){
    // Invert b's sign bit
    signedint_t bInt = b
    bInt.s = !bInt.s

    signedint_t outInt = Addsignedint_ts(a, bInt);

    return outInt
}

signedint_t Multsignedint_ts(signedint_t a, signedint_t b){
    // Determine final sign, if they are different it is 1, if they are both 0 it is 0, and if they are both 1 it is also 0
    var finalSign = 0
    if(a.s != b.s)
        finalSign = 1

    var finalVal = a.val*b.val
    signedint_t outInt = {s:finalSign, val:finalVal};

    return outInt
}

// Subtract two ints, and return a signed int to allow for negative numbers
signedint_t SubTosignedint_t(int a, int b){
	var aval = a
	var bval = b
    // Convert each to a signed int
    signedint_t aInt = {s:0, val:aval};
    signedint_t bInt = {s:1, val:bval}; // Invert b's sign

	signedint_t outInt = {s:0, val:0};
    outInt = Addsignedint_ts(aInt, bInt);

    return outInt
}

signedint_t Signed(int a){
    signedint_t outInt = {s: 0, val:a};
    return outInt
}

signedint_t NegativeSigned(int a){
    a = a & 0b111111111111111;
    signedint_t outInt = {s: 1, val:a};
    return outInt
}

// Return the integer rounded approximation of a float
int FloatToUnsignedInt(float16_t fl){
    var tmpF = fl.fraction + 0b10000000000

    var tmpE = fl.exponent - 15

    var ouval = deNormalizeFraction(tmpF, tmpE) // Int version

    return ouval
}

// Return the signed integer rounded approximation of a float
signedint_t FloatToInt(float16_t fl){
    var tmpF = fl.fraction + 0b10000000000
    // tmpF = TruncateTrailingZeros(tmpF)

    var tmpE = fl.exponent - 15

    var si = fl.sign

    // int out = tmpF >> get_shift_amnt(tmpF, tmpE)

    var ouval = deNormalizeFraction(tmpF, tmpE) // Int version

    signedint_t out = { s:si, val:ouval }; // Add correct sign

    return out
}

bool Comparesignedint_ts(signedint_t a, signedint_t b, int comp){
    int compresult = 0 // This stores the result of the comparison, 0 is for equal, 1 is if a > b, and 2 is if a < b

    // If a is negative and b is not it is only less than
    if(a.s > b.s){
        compresult = 2
    }
    // If b is negative and a is not it is only greater than
    else if(a.s < b.s){
        compresult = 1
    }
    // If the signs are both negative, check each absolute value
    //   (sinZe we are negative, a greater magnitude means a lower number)
    else if(a.s == 1){
        // If the values are the same
        if(a.val == b.val){
            compresult = 0
        }
        // If a is greater than b
        else if(a.val > b.val){
            compresult = 2
        }
        // If b is greater than a
        else if(a.val < b.val){
            compresult = 1
        }
    }
    // If the signs are both positive, check each absolute value
    else if(a.s == 0){
        // If the values are the same
        if(a.val == b.val){
            compresult = 0
        }
        // If a is greater than b
        else if(a.val > b.val){
            compresult = 1
        }
        // If b is greater than a
        else if(a.val < b.val){
            compresult = 2
        }
    }


    // Now that the actual comparision is done, return a true or false based upon what we are looking for in `comp`
    if(comp == '='){ // Equal
        if(compresult == 0)
            return true
    }
    else if(comp == '>'){ // Greater
        if(compresult == 1)
            return true
    }
    else if(comp == '<'){ // Less
        if(compresult == 2)
            return true
    }

    return false
}

bool CompareFloats(float16_t a, float16_t b, int comp){
    int compresult = 0 // This stores the result of the comparison, 0 is for equal, 1 is if a > b, and 2 is if a < b

    // If a is negative and b is not it is only less than
    if(a.sign > b.sign){
        compresult = 2
    }
    // If b is negative and a is not it is only greater than
    else if(a.sign < b.sign){
        compresult = 1
    }
    // If the signs are both negative, check each absolute value
    //   (sinZe we are negative, a greater magnitude means a lower number)
    else if(a.sign == 1){
        // If the exponents are the same, compare mantisssas
        if(a.exponent == b.exponent){
            // If they are the same, then these values are equal
            if(a.fraction == b.fraction){
                compresult = 0
            }
            // Else if a mantissa is greater than b
            else if(a.fraction > b.fraction){
                compresult = 2 // A greater mantissa means a lower negative number
            }
            // Else if b mantissa is greater than a
            else if(b.fraction > a.fraction){
                compresult = 1
            }
        }
        // If a is greater than b
        else if(a.exponent > b.exponent){
            compresult = 2
        }
        // If b is greater than a
        else if(a.exponent < b.exponent){
            compresult = 1
        }
    }
    // If the signs are both positive, check each absolute value
    else if(a.sign == 0){
        // If the exponents are the same, compare mantisssas
        if(a.exponent == b.exponent){
            // If they are the same, then these values are equal
            if(a.fraction == b.fraction){
                compresult = 0
            }
            // Else if a mantissa is greater than b
            else if(a.fraction > b.fraction){
                compresult = 1
            }
            // Else if b mantissa is greater than a
            else if(b.fraction > a.fraction){
                compresult = 2
            }
        }
        // If a is greater than b
        else if(a.exponent > b.exponent){
            compresult = 1
        }
        // If b is greater than a
        else if(a.exponent < b.exponent){
            compresult = 2
        }
    }


    // Now that the actual comparision is done, return a true or false based upon what we are looking for in `comp`
    if(comp == '='){ // Equal
        if(compresult == 0)
            return true
    }
    else if(comp == '>'){ // Greater
        if(compresult == 1)
            return true
    }
    else if(comp == '<'){ // Less
        if(compresult == 2)
            return true
    }

    return false
}

// Return the integer rounded approximation of a float
float16_t IntToFloat(signedint_t x){
    // Find the exponent, by shifting left until the largest digit is reached
    var count = 1
    var tmp = x.val
    var mask = 1
    for (var i = 0; i < 16; i++){
        // If the first digit is 1, then stop shifting because we have the count
        if((tmp & 0b1000000000000000) == 0b1000000000000000)
            break
        // Otherwise shift again
        tmp = tmp << 1
        count += 1
    }
    // Get exponent from count, then add offset of 15 for float format
    var exp = (15-count)+15

    var mant = x.val
    // If the mantissa is >= 10 bits long already, only use first 10
    if(mant > 0b11111111111){
        mant = mant >> ((16-count)-11)
    }
    else if(mant < 0b10000000000){
        mant = mant << (11-(16-count))
    }

    float16_t outFloat = normalizeFloat(mant, exp);
    outFloat.sign = x.s

    return outFloat
}

float16_t AddFloats(float16_t floatA, float16_t floatB){
    float16_t outFloat = { sign : 0, exponent : 0, fraction : 0 };
    // If the exponents are different, then we need to make the float with the smaller exponent the same as the larger one
    if(floatA.exponent > floatB.exponent){
        var tmpMB = ((floatB.fraction+0b10000000000)>>(floatA.exponent-floatB.exponent))
        var tmpMA = floatA.fraction+0b10000000000

        bool finalSign = false
        if(floatB.sign == true){
            tmpMB = Negative(tmpMB)
            // Determine the final sign, it is 1 if B is > A
            if(floatB.exponent > floatA.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatB.exponent == floatA.exponent) && (floatB.fraction > floatA.fraction))
                finalSign = true
        }
        if(floatA.sign == true){
            tmpMA = Negative(tmpMA)
            // Determine the final sign, it is 1 if A is > B
            if(floatA.exponent > floatB.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatA.exponent == floatB.exponent) && (floatA.fraction > floatB.fraction))
                finalSign = true
        }

        int tmpM = tmpMA+tmpMB
        int exp = floatA.exponent
        outFloat = { sign : finalSign, exponent : exp, fraction : tmpM };
        if ((tmpM & 0b10000000000) != 0b10000000000) // If the 11th bit is 0, then normalize
            outFloat = normalizeFloat(tmpM, exp)
    }
    // 150+500
    else if(floatA.exponent < floatB.exponent){
        int tmpMB = floatB.fraction+0b10000000000
        int tmpMA = ((floatA.fraction+0b10000000000)>>(floatB.exponent-floatA.exponent))

        bool finalSign = false
        if(floatB.sign == true){
            tmpMB = Negative(tmpMB)
            // Determine the final sign, it is 1 if B is > A
            if(floatB.exponent > floatA.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatB.exponent == floatA.exponent) && (floatB.fraction > floatA.fraction))
                finalSign = true
        }
        if(floatA.sign == true){
            tmpMA = Negative(tmpMA)
            // Determine the final sign, it is 1 if A is > B
            if(floatA.exponent > floatB.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatA.exponent == floatB.exponent) && (floatA.fraction > floatB.fraction))
                finalSign = true
        }

        int tmpM = tmpMA+tmpMB

        int exp = floatB.exponent
        outFloat = { sign : finalSign, exponent : exp, fraction : tmpM };
        if ((tmpM & 0b10000000000) != 0b10000000000) // If the 11th bit is 0, then normalize
            outFloat = normalizeFloat(tmpM, floatB.exponent)
    }
    // Else the exponents are the same, so no need to change them
    else {
        int tmpMB = (floatB.fraction+0b10000000000)>>1
        int tmpMA = (floatA.fraction+0b10000000000)>>1

        bool finalSign = false
        if(floatB.sign == true){
            tmpMB = Negative(tmpMB)
            // Determine the final sign, it is 1 if B is > A
            if(floatB.exponent > floatA.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatB.exponent == floatA.exponent) && (floatB.fraction > floatA.fraction))
                finalSign = true
        }
        if(floatA.sign == true){
            tmpMA = Negative(tmpMA)
            // Determine the final sign, it is 1 if A is > B
            if(floatA.exponent > floatB.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatA.exponent == floatB.exponent) && (floatA.fraction > floatB.fraction))
                finalSign = true
        }

        int tmpM = tmpMA+tmpMB

        int exp = floatB.exponent+1
        outFloat = { sign : finalSign, exponent : exp, fraction : tmpM };
        if ((tmpM & 0b10000000000) != 0b10000000000) // If the 11th bit is 0, then normalize
            outFloat = normalizeFloat(tmpM, floatB.exponent)
    }

    return outFloat
}

float16_t SubFloats(float16_t floatA, float16_t floatB){
    float16_t fb = floatB
    fb.sign = !fb.sign
    return AddFloats(floatA, fb)
}


float16_t MultFloats(float16_t floatA, float16_t floatB){
    int tmpMA = floatA.fraction+0b10000000000
    int tmpMB = floatB.fraction+0b10000000000

    int snA = floatA.sign
    int snB = floatB.sign

    // Determine final sign, if they are different it is 1, if they are both 0 it is 0, and if they are both 1 it is also 0
    var finalSign = 0
    if(snA != snB)
        finalSign = 1

    // Get the lowest bit that is 1 in either A or B
    var count = 0 // count is for the lowest index there is a 1
    for (var i = 0; i < 16; i++){
        // If the lowest bit in A or B is 1, stop the loop
        if(((tmpMA & 1) == 1) || ((tmpMB & 1) == 1))
            break
        else{
            // Shift right
            tmpMA = tmpMA >> 1
            tmpMB = tmpMB >> 1
            count += 1
        }
    }

    int tmpM = tmpMA*tmpMB
    int exp = floatA.exponent+floatB.exponent-15+count-4

    float16_t outFloat = { sign : finalSign, exponent : exp, fraction : tmpM };
    if ((tmpM & 0b10000000000) != 0b10000000000) // If the 11th bit is 0, then normalize
        outFloat = normalizeFloat(tmpM, exp)

    return outFloat
}

// Credit to njuffa (https://cs.stackexchange.com/users/51535/njuffa),
// "Simple algorithm for IEEE-754 division on 8-bit CPU?"",
// URL (version: 2019-02-28): https://cs.stackexchange.com/q/104961
float16_t DivFloats (float16_t a, float16_t b)
{
    int r = 0
    int x = 0
    int y = 0
    int sign = 0

    int expo_x = 0
    int expo_y = 0

    int i = 0
    int odd = 0
    int rnd = 0
    int sticky = 0

    float16_t outVal = {sign:0, exponent:0, fraction:0};

    /* extract biased exponents and sign bits */
    expo_x = a.exponent
    expo_y = b.exponent
    sign = XOR(a.sign, b.sign)

    var processNow = false

    for (var jj = 0; jj < 2; jj++){
        if (((expo_x >= 1) && (expo_x <= 0b11110) &&
            (expo_y >= 1) && (expo_y <= 1)) || processNow) { /* fast path */
    // divide:
            /* add significand leading 1 int */
            x = a.fraction + 0b10000000000
            y = b.fraction + 0b10000000000
            /* compute exponent of result */
            outVal.exponent = expo_x - expo_y + 15
            /* dividend may not be smaller than divisor: normalize */
            if (x < y) {
                x = x << 1
                outVal.exponent -= 1
            }
            /* generate quotient one bit at at time */
            r = 0
            for (i = 0; i < 12; i++) {
                r = r << 1
                if (x >= y) {
                    x = x - y
                    r = r | 1
                }
                x = x << 1
            }
            /* OR remainder bits into sticky bit */
            sticky = (x != 0)
            if ((outVal.exponent >= 1) &&
                (outVal.exponent <= 0b11110)) { /* normal, may overflow to infinity*/
                /* extract round and lsb bits */
                rnd = (r & 1)
                odd = (r & 2) != 0
                /* remove round bit from quotient and round to-nearest-even */
                r = (r >> 1) + (rnd & (sticky | odd))
                /* set significand */
                outVal.fraction = r - 0b10000000000
            } else if (outVal.exponent > 0b11110) { // overflow: infinity
                outVal.exponent = 0b011111
            } else { /* underflow: result is zero, subnormal, or smallest normal */
                int shift = (1 - outVal.exponent)
                /* clamp shift count */
                if (shift > 12) shift = 12
                /* OR shifted-off bits of significand into sticky bit */
                sticky = sticky | ((r & NOT(NOT(0) << shift)) != 0)
                /* denormalize significand */
                r = r >> shift
                /* extract round and lsb bits */
                rnd = (r & 1)
                odd = (r & 2) != 0
                /* remove round bit from quotient and round to-nearest-even */
                // r = (r >> 1) + (rnd & (sticky | odd));
                outVal.fraction = (r >> 1) + (rnd & (sticky | odd))
            }
            // /* combine sign bit with combo of exponent and significand */
            // r = r | sign;
            outVal.sign = sign
        } else { /* slow path */
            // /* take absolute value of arguments */
            // x = a & NOT(SIGN_MASK);
            // y = b & NOT(SIGN_MASK);
            /* if dividend is a NaN, convert that NaN into a QNaN and return it */
            if ((a.exponent == 0b11111) && (a.fraction > 0)){
                outVal.sign = a.sign
                outVal.fraction = a.fraction | 0b1000000000
                outVal.exponent = a.exponent
                return outVal
            }
            /* if divisor is a NaN, convert that NaN into a QNaN and return it */
            if ((b.exponent == 0b11111) &&(b.fraction > 0)){
                outVal.sign = b.sign
                outVal.fraction = b.fraction | 0b1000000000
                outVal.exponent = b.exponent
                return outVal
            }
            /* dividend and divisor are both zero or infinity: invalid operation */
            if (((a.exponent == 0 && a.fraction == 0) && (b.exponent == 0 && b.fraction == 0)) ||
                ((a.exponent == 0b11111) && (b.exponent == 0b11111)))
            {
                outVal.sign = 1
                outVal.fraction = 0b1000000000
                outVal.exponent = 0b11111
                return outVal
            }
            /* 0/y or x/INF -> 0 */
            if ((a.exponent == 0 && a.fraction == 0) || (a.exponent == 0b11111))
            {
                outVal.sign = sign
                return outVal
            }
            /* x/0 or INF/y -> INF */
            if ((b.exponent == 0 && b.fraction == 0) || (a.exponent == 0b11111))
            {
                outVal.sign = sign
                outVal.fraction = 0
                outVal.exponent = 0b11111
                return outVal
            }
            /* if dividend is a subnormal, normalize it */
            if (expo_x == 0) {
                expo_x += 1
                int afrac = a.fraction
                for (var afs = 0; afs < 16; afs++){
                    if((afrac & 0b10000000000)==0b10000000000)
                        break
                    afrac = afrac << 1
                    expo_x -= 1
                }
                a.fraction = afrac
            }
            /* if divisor is a subnormal, normalize it */
            if (expo_y == 0) {
                expo_y += 1
                int bfrac = b.fraction
                for (var bs = 0; bs < 16; bs++){
                    if((bfrac & 0b10000000000)==0b10000000000)
                        break
                    bfrac = bfrac << 1
                    expo_y -= 1
                }
                b.fraction = bfrac
            }
            /* now that dividend and divisor are normalized, do the division */
            // goto divide
            processNow = true
        }
    }

    return outVal
}


// /////////////////////////
// // These are the tests //
// /////////////////////////

// ChangeHighlightColor(0, 0, 200)
// write('f')
// write('l')
// write('o')
// write('a')
// write('t')
// write(' ')
// write('t')
// write('e')
// write('s')
// write('t')
// write('s')
// write(':')
// newline()

// // // herethisis:
// // var valu = 0b1000000001
// // newline()
// // write_binary(valu)
// // valu = valu^0b1100000001
// // newline()
// // write_binary(valu)
// // // goto herethisis


// // float16_t f16 = { sign : 1, exponent : 5, fraction : 10 };
// // write_int(f16.exponent)
// signedint_t correctVal = {s:0, val:0};
// signedint_t val = {s:0, val:0};
// // write_signed_int(RetSame(val))

// // t1: Float to int 1022
// correctVal = {s:0, val:1022};
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('1')
// write(' ')
// float16_t inValue = IntToFloat(correctVal);
// val = FloatToInt(inValue)
// // newline()
// // write_float(inValue)
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()

// // t2: Float to int 2751
// correctVal = {s:0, val:2751};
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('2')
// write(' ')
// float16_t inValue = IntToFloat(correctVal);
// val = FloatToInt(inValue)
// // newline()
// // write_float(inValue)
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()
// // write_binary(val) // Binary should be: 0000000010100000

// // // t2: Add floats 160 + 160 = 320
// // correctVal = 320
// // ChangeHighlightColor(0, 128, 128)
// // write('t')
// // write('2')
// // write(' ')
// // float16_t t2a = { sign : 0, exponent : 0b10110, fraction : 0b0100000000 };
// // float16_t t2b = { sign : 0, exponent : 0b10110, fraction : 0b0100000000 };
// // val = AddFloats(t2a, t2b)
// // if(WithinRange(correctVal, val, 10) == false)
// //     ChangeHighlightColor(230, 0, 0)
// // else
// //     ChangeHighlightColor(0, 230, 0)
// // write_int(val)
// // write(' ')
// // ChangeHighlightColor(128, 128, 0)
// // write_int(correctVal)
// // ChangeHighlightColor(0, 128, 128)
// // newline()
// // newline()

// // t3: Add floats 150 + 500 = 650
// signedint_t AVal = {s:0, val:150};
// signedint_t BVal = {s:0, val:500};
// correctVal = {s:0, val:(AVal.val+BVal.val)};
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('3')
// write(' ')
// float16_t inValueA = IntToFloat(AVal);
// write_signed_int(FloatToInt(inValueA))
// float16_t inValueB = IntToFloat(BVal);
// write('+')
// write_signed_int(FloatToInt(inValueB))
// val = FloatToInt(AddFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write('=')
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)

// // t4: Add floats 700 + 140 = 840
// signedint_t AVal = {s:0, val:700};
// signedint_t BVal = {s:0, val:140};
// correctVal = {s:0, val:(AVal.val + BVal.val)};
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('4')
// write(' ')
// float16_t inValueA = IntToFloat(AVal);
// write_signed_int(FloatToInt(inValueA))
// float16_t inValueB = IntToFloat(BVal);
// write('+')
// write_signed_int(FloatToInt(inValueB))
// val = FloatToInt(AddFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write('=')
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)

// // t5: Add floats 3000 + -7000 = -4000
// signedint_t AVal = {s:0, val:3000};
// signedint_t BVal = {s:1, val:7000};
// correctVal = {s:0, val:(AVal.val - BVal.val)};
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('5')
// write(' ')
// float16_t inValueA = IntToFloat(AVal);
// write_signed_int(FloatToInt(inValueA))
// float16_t inValueB = IntToFloat(BVal);
// write('+')
// write_signed_int(FloatToInt(inValueB))
// val = FloatToInt(AddFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write('=')
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()

// // t6: Multiply floats 50 * 4 = 200
// signedint_t AVal = {s:0, val:50};
// signedint_t BVal = {s:0, val:4};
// correctVal = {s:0, val:(AVal.val*BVal.val)};
// write('t')
// write('6')
// write(' ')
// float16_t inValueA = IntToFloat(AVal);
// float16_t inValueB = IntToFloat(BVal);
// val = FloatToInt(MultFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()

// // t7: Multiply floats 17 * 0.5 = 8.5
// signedint_t AVal = {s:0, val:17};
// correctVal = {s:0, val:(AVal.val/2)};
// write('t')
// write('7')
// write(' ')
// float16_t inValueA = IntToFloat(AVal);
// float16_t inValueB = { sign : 0, exponent : 0b01110, fraction : 0 };
// val = FloatToInt(MultFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()

// // t8: Subtract floats 140 - 37 = 107
// signedint_t AVal = {s:0, val:140};
// signedint_t BVal = {s:0, val:37};
// correctVal = {s:0, val:(AVal.val-BVal.val)};
// write('t')
// write('8')
// write(' ')
// float16_t inValueA = IntToFloat(AVal);
// float16_t inValueB = IntToFloat(BVal);
// val = FloatToInt(SubFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()
// // write_binary(val)
// // newline()

// // t9: Divide floats 70 / 24 = 80
// signedint_t AVal = {s:0, val:70};
// // signedint_t BVal = {s:0, val:3};
// correctVal = {s:0, val:116};
// write('t')
// write('9')
// write(' ')
// float16_t inValueA = IntToFloat(AVal);
// float16_t inValueB = {sign:0, fraction:0b0011001100, exponent:0b01110};
// val = FloatToInt(DivFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()


// // tx: Divide floats 10 / 2 = 5
// signedint_t AVal = {s:0, val:10};
// signedint_t BVal = {s:0, val:2};
// correctVal = {s:0, val:(AVal.val/BVal.val)};
// write('t')
// write('x')
// write(' ')
// float16_t inValueA = IntToFloat(AVal);
// float16_t inValueB = IntToFloat(BVal);
// val = FloatToInt(DivFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()

// // t5: Float to int 1.7
// write('t')
// write('5')
// write(' ')
// float16_t t5 = { sign : 0, exponent : 0b01111, fraction : 0b1011001100 };
// val = FloatToInt(t5)
// write_int(val)
// newline()
// newline()

// // t6: Int to Float to int 0 through 10000
// write('t')
// write('6')
// write(' ')
// // Iterate through all values 0 through 10000, and count the number of incorrect
// var numWrong = 0
// var startWrong = 0
// var endWrong = 0
// for (var i = 0; i < 10000; i++){
//     correctVal = i
//     float16_t t6 = IntToFloat(correctVal);
//     // t6 = normalizeFloat(t6.fraction, t6.exponent)
//     // float16_t t6 = { sign : 0, exponent : 0b10100, fraction : 0b0010000000 };
//     val = FloatToInt(t6)
//     if(WithinRange(correctVal, val, 10) == false){
//         numWrong += 1
//         if(startWrong==0)
//             startWrong = i

//         endWrong = i
//         // write_int(i)
//         // break
//     }
// }
// write(' ')
// write('w')
// write('r')
// write('o')
// write('n')
// write('g')
// write(':')
// write(' ')
// ChangeHighlightColor(128, 0, 128)
// if(numWrong > 0)
//     write_int(numWrong)
// else{
//     ChangeHighlightColor(0, 230, 0)
//     write('n')
//     write('o')
//     write('n')
//     write('e')
// }
// newline()
// ChangeHighlightColor(0, 128, 128)
// write('s')
// write('t')
// write('a')
// write(':')
// write(' ')
// write_int(startWrong)
// newline()
// write('e')
// write('n')
// write('d')
// write(':')
// write(' ')
// write_int(endWrong)
// newline()


//cout << DecimalToBinaryString(val) << " : " << val << endl

//    cout << "Float To Int: 13.78" <<endl;
//    val = FloatToInt(0, 0b10010, 0b1011100011);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Float To Int: 2100" <<endl;
//    val = FloatToInt(0, 0b11010, 0b0000011010);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Float To Int: 3.141" <<endl;
//    val = FloatToInt(0, 0b10000, 0b1001001000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Add floats: 3.141 + 20 = 23.141" <<endl;
//    val = AddFloats(0, 0b10000, 0b1001001000, 0, 0b10011, 0b0100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Add floats: 281 + 425.5 = 706.5" <<endl;
//    val = AddFloats(0, 0b10111, 0b0001100100, 0, 0b10111, 0b1010100110);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Sub floats: 800 - 425.5 = 374.5" <<endl;
//    val = SubFloats(0, 0b11000, 0b1001000000, 0, 0b10111, 0b1010100110);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 15 * 3.5 = 52.5" <<endl;
//    val = MultFloats(0, 0b10010, 0b1110000000, 0, 0b10000, 0b1100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 300 * 3.5 = 1050" <<endl;
//    val = MultFloats(0, 0b10111, 0b0010110000, 0, 0b10000, 0b1100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 300 * 0.5 = 150" <<endl;
//    val = MultFloats(0, 0b10111, 0b0010110000, 0, 0b01110, 0b0000000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 0.5 * 0.5 = 0.25" <<endl;
//    val = MultFloats(0, 0b01110, 0b0000000000, 0, 0b01110, 0b0000000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

// while (true) {

// }


struct float16_t {
    int sign : 1
    int exponent : 5
    int fraction : 10
}

struct signedint_t {
    int val : 15
    int s : 1
}

struct Point {
    int x : 8
    int y : 8
}

signedint_t operator &(signedint_t a, signedint_t b) {
    return { val: a.val & b.val, s: a.s & b.s }
}

signedint_t operator &(signedint_t a, int b) {
    return { val: a.val & b, s: a.s & (b>>15) }
}

bool operator >(signedint_t a, int b) {
    return a.s == 1 || a.val > b;
}

signedint_t operator /(signedint_t a, int b) {
    return { val: a.val / b, s: a.s }
}

signedint_t operator /(signedint_t a, signedint_t b) {
    return { val: a.val / b.val, s: a.s ^ b.s }
}

signedint_t operator *(signedint_t a, signedint_t b) {
    return { val: a.val * b.val, s: a.s ^ b.s }
}

signedint_t operator +(signedint_t a, signedint_t b) {
    return Addsignedint_ts(a, b)
}

signedint_t operator +(signedint_t a, int b) {
    return Addsignedint_ts(a, b)
}

signedint_t operator +(int a, signedint_t b) {
    return Addsignedint_ts(a, b)
}

signedint_t operator -(signedint_t a, signedint_t b) {
    return Subsignedint_ts(a, b)
}

signedint_t operator |(signedint_t a, int b) {
    return { val: a.val | b, s: a.s | (b>>15) }
}

Point operator |(Point a, int b) {
    return { x: a.x | b, y: (a.y<<8) | b }
}

Point operator &(Point a, int b) {
    return { x: a.x & b, y: (a.y<<8) & b }
}

Point operator >>(Point a, int b) {
    return ((a.y<<8)|a.x)>>b
}

Point operator /(Point a, int b) {
    return { x: a.x / b, y: a.y / b }
}
