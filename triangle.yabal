
// import "float.yabal"

var floats = create_pointer<Float16>(0x0, 1);
var signedInts = create_pointer<SignedInt>(0x1111, 1);

var screen = create_pointer(53871, 1)

var expansionPorts = create_pointer(53500, 1)

var chars = create_pointer(53546, 1)
// var offset = 0

const Float16 FLOAT_ZERO = { sign : 0, exponent : 0, fraction : 0 };
const Float16 ONE = { sign : 0, exponent : 0b01111, fraction : 0 };

// inline int get_color(int r, int g, int b) {
//     return (r / 8 << 10) + (g / 8 << 5) + (b / 8);
// }

// int sign (int p1x, int p1y, int p2x, int p2y, int p3x, int p3y)
// {
//     return ((p1x - p3x) * (p2y - p3y) - (p2x - p3x) * (p1y - p3y))
// }

// int PointInTriangle (int px, int py, int t1x, int t1y, int t2x, int t2y, int t3x, int t3y)
// {
//     var d1 = 0
//     var d2 = 0
//     var d3 = 0
//     var has_neg = false
//     var has_pos = false

//     d1 = sign(px, py, t1x, t1y, t2x, t2y)
//     d2 = sign(px, py, t2x, t2y, t3x, t3y)
//     d3 = sign(px, py, t3x, t3y, t1x, t1y)

//     has_neg = (d1 > 60000) || (d2 > 60000) || (d3 > 60000)
//     has_pos = (d1 < 60000) || (d2 < 60000) || (d3 < 60000)

//     return !(has_neg && has_pos)
// }

// // Function foor drawign a single pixel to the screen
// void SetPixel(int x, int y, int color){
//     var screenOffset = (y * 108) + x
//     screen[screenOffset] = color
// }


// // Bresenham's line algorithm
// void DrawLine(Float16 x1, Float16 y1, Float16 x2, Float16 y2, int color)
// {
//   bool steep = false
//   Float16 y2y1sub = fabs(SubFloats(y2 - y1))
//   Float16 x2x1sub = fabs(SubFloats(x2 - x1))
//   // Compare if y2y1sub is greater than x2x1sub
//   if(y2y1sub.exponent-15 >= x2x1sub.exponent-15){
//     if(y2y1sub.fraction > x2x1sub.fraction)
//         steep = true
//   }
// else if(y2y1sub.exponent-15 == x2x1sub.exponent-15){
//   steep = true
// }
//   if(steep)
//   {
//     // Swap x1 and y1
//     Float16 tmpx1 = x1
//     x1 = y1
//     y1 = tmpx1
//     // Swap x2 and y2
//     Float16 tmpx2 = x2
//     x2 = y2
//     y2 = tmpx2
//   }

//   if(x1 > x2)
//   {
//     // Swap x1 and x2
//     Float16 tmpx1 = x1
//     x1 = x2
//     x2 = tmpx1
//     // Swap y1 and y2
//     Float16 tmpy1 = y1
//     y1 = y2
//     y2 = tmpy1
//   }

//   Float16 dx = SubFloats(x2 - x1)
//   Float16 dy = fabs(SubFloats(y2 - y1))
  
//   //Float16 two = { sign : 0, exponent : 10000, fraction : 0 };
//   Float16 error = DivFloats(dx, IntToFloat(2))
//   SignedInt ystep = {s:0, val:1};
//   if (y1 < y2){
//       ystep.s = 0
//   }
//   else{
//       ystep.s = 1
//   }
//   SignedInt y = IntToSignedInt(FloatToInt(y1))

//   SignedInt maxX = FloatToInt(x2)

//   var strt = FloatToInt(x1)
//   for(var x=strt; x<=maxX.val; x++)
//   {
//     if(steep)
//         SetPixel(y.val,x, color)
//     else
//         SetPixel(x,y.val, color)
              
//     error = SubFloats(error, dy)
//     SignedInt intError = FloatToInt(error)
//     var errorSign = intError.s
//     if(errorSign == true) // If error is less than 0, ie sign bit is 1
//     {
//         y = AddSignedInts(y, ystep)
//         error = AddFloats(error, dx)
//     }
//   }
// }


// void DrawLine(int x1,int y1,int x2,int y2, int color)
// {

//     // Bresenham's line algorithm
//     var suby2y1 = 0
//     if(y2>y1)
//         suby2y1=y2- y1
//     else
//         suby2y1=y1- y2
//     var subx2x1 = 0
//     if(x2>x1)
//         subx2x1=x2-x1
//     else
//         subx2x1=x1-x2

//     bool steep = suby2y1>subx2x1
//     if (steep) {
//         // std::swap(x1, y1);
//         var swapper = x1
//         x1 = y1
//         y1 = swapper
//         // std::swap(x2, y2);
//         var swapper = x2
//         x2 = y2
//         y2 = swapper
//     }

//     if (x1 > x2) {
//         // std::swap(x1, x2);
//         var swapper = x1
//         x1 = x2
//         x2 = swapper
//         // std::swap(y1, y2);
//         var swapper = y1
//         y1 = y2
//         y2 = swapper
//     }

// 	SignedInt dx = {s:0, val:0};
//     SignedInt dy = {s:0, val:0};
//     SignedInt p = {s:0, val:0};
// 	dx=SubSignedInts(Signed(x2), x1)
// 	dy=SubSignedInts(Signed(y2), y1)
//     SignedInt tmpDy = dy
//     tmpDy.val = tmpDy.val *2
// 	p = SubSignedInts(tmpDy, dx)
//     SignedInt tmpDyDx = SubSignedInts(dy, dx)
//     tmpDyDx.val = tmpDyDx.val *2
// 	while(x1 <= x2)
// 	{
// 		if(p.s == 1) // If less than 0
// 		{
// 			x1=x1+1
//             p = AddSignedInts(p, tmpDy)
// 		}
// 		else
// 		{
// 			x1=x1+1
// 			y1=y1+1
// 			p = AddSignedInts(p, tmpDyDx)
// 		}
// 		SetPixel(x1,y1,color)
// 	}
// }


// void DrawLine(int x1, int y1, int x2, int y2, int color) {

//     x1 = IntToFloat(x1)
//     y1 = IntToFloat(y1)
//     x2 = IntToFloat(x2)
//     y2 = IntToFloat(y2)

//     // Bresenham's line algorithm
//     var suby2y1 = SubFloats(y2, y1)
//     var subx2x1 = SubFloats(x2, x1)
//     bool steep = CompareFloats(fabs(suby2y1), fabs(subx2x1), '>')
//     if (steep) {
//         // std::swap(x1, y1);
//         var swapper = x1
//         x1 = y1
//         y1 = swapper
//         // std::swap(x2, y2);
//         var swapper = x2
//         x2 = y2
//         y2 = swapper
//     }

//     if (x1 > x2) {
//         // std::swap(x1, x2);
//         var swapper = x1
//         x1 = x2
//         x2 = swapper
//         // std::swap(y1, y2);
//         var swapper = y1
//         y1 = y2
//         y2 = swapper
//     }

//     Float16 dx = SubFloats(x2, x1)
//     Float16 dy = fabs(SubFloats(y2, y1))

//     Float16 half = {sign: 0, exponent:0b01110, fraction:0};
//     Float16 error = MultFloats(dx, half)

//     // int ystep = (y1 < y2) ? 1 : -1;
//     SignedInt ystep = {s:0, val:1};
//     if (y1 < y2){
//         ystep.s = 0
//     }
//     else{
//         ystep.s = 1
//     }

//     var y = FloatToUnsignedInt(y1)
//     SignedInt yTmp = {s:0, val:y};

//     var maxX = FloatToUnsignedInt(x2)

//     var flX1 = FloatToUnsignedInt(x1)

//     for (var x = flX1; x <= maxX; x++) {
//         if (steep) {
//             SetPixel(y, x, color)
//         }
//         else {
//             SetPixel(x, y, color)
//         }

//         // error -= dy
//         error = SubFloats(error, dy)
//         if (error.sign == 1) {
//             yTmp = AddSignedInts(yTmp, ystep)
//             y = yTmp.val
//             // error += dx
//             error = AddFloats(error, dx)
//         }
//     }
// }

// void DrawLine(int x0i, int y0i, int x1i, int y1i, int color){
//     SignedInt x0 = Signed(x0i)
//     SignedInt y0 = Signed(y0i)
//     SignedInt x1 = Signed(x1i)
//     SignedInt y1 = Signed(y1i)

//     // int x0,y0,x1,y1;
//     // cout<<"Enter the First Line Coordinates";
//     // cin>>x0>>y0;
//     // cout<<"Enter the Second Line Coordinates";
//     // cin>>x1>>y1;

//     // // Old C++
//     // int dx=x1-x0
//     // int dy=y1-y0
//     // int d=2*dy-dx
//     // int incrE=2*dy
//     // int incrNE=2*(dy-dx)
//     // int x=x0
//     // int y=y0

//     // dx=x1-x0
//     SignedInt dx = SubSignedInts(x1, x0)
//     // dy=y1-y0
//     SignedInt dy = SubSignedInts(y1,y0)
//     // d=2*dy-dx
//     SignedInt d = dy
//     d.val = (d.val*2) - dx
//     // incrE=2*dy
//     SignedInt incrE = dy
//     incrE.val = incrE.val * 2
//     // incrNE=2*(dy-dx)
//     SignedInt incrNE = SubSignedInts(dy, dx)
//     incrNE.val = incrNE.val * 2
//     // x=x0
//     SignedInt x = x0
//     // y=y0
//     SignedInt y = y0
    
//     SetPixel(x.val,y.val,color)

//     while(CompareSignedInts(x, x1, '<'))
//     {
//         if(d.s == 1)
//         {
//             d = AddSignedInts(d, incrE)
//             x +=1
//         }
//         else
//         {
//             d = AddSignedInts(d, incrNE)
//             x +=1
//             y +=1
//         }
//         SetPixel(x.val,y.val,color);
//     }
// }

// void Bresenham(int x1, int y1, int x2, int y2)
// {
//     int delta_x= Delta(x2 - x1)
//     // if x1 == x2, then it does not matter what we set here
//     signed char const ix((delta_x > 0) - (delta_x < 0));
//     delta_x = std::abs(delta_x) << 1;

//     int delta_y(y2 - y1);
//     // if y1 == y2, then it does not matter what we set here
//     signed char const iy((delta_y > 0) - (delta_y < 0));
//     delta_y = std::abs(delta_y) << 1;

//     plot(x1, y1);

//     if (delta_x >= delta_y)
//     {
//         // error may go below zero
//         int error(delta_y - (delta_x >> 1));
 
//         while (x1 != x2)
//         {
//             // reduce error, while taking into account the corner case of error == 0
//             if ((error > 0) || (!error && (ix > 0)))
//             {
//                 error -= delta_x;
//                 y1 += iy;
//             }
//             // else do nothing

//             error += delta_y;
//             x1 += ix;

//             plot(x1, y1);
//         }
//     }
//     else
//     {
//         // error may go below zero
//         int error(delta_x - (delta_y >> 1));

//         while (y1 != y2)
//         {
//             // reduce error, while taking into account the corner case of error == 0
//             if ((error > 0) || (!error && (iy > 0)))
//             {
//                 error -= delta_y;
//                 x1 += ix;
//             }
//             // else do nothing

//             error += delta_x;
//             y1 += iy;
 
//             plot(x1, y1);
//         }
//     }
// }

// void DrawLine(int x_starti, int y_starti, int x_endi, int y_endi, int c){
//     SignedInt x_start = Signed(x_starti)
//     SignedInt y_start = Signed(y_starti)
//     SignedInt x_end = Signed(x_endi)
//     SignedInt y_end = Signed(y_endi)
//     // """
//     // Implementation of Bresenham's line algorithm in Python. This will work for positive sloped lines
//     // with a gradient between 0 and 1 only. Also, x_start < x_end and y_start < y_end must be true.
//     // """
//     SignedInt dy = SubSignedInts(y_end, y_start)
//     SignedInt dx = SubSignedInts(x_end, x_start)
//     // # Note that the initial error does not start at zero!
//     SignedInt error = dy
//     error.val = error.val<<1
//     error.val = SubSignedInts(error.val, dx)

//     SignedInt dxX2 = dx
//     dxX2.val = (dx.val)<<1
//     SignedInt dyX2 = dy
//     dyX2.val = (dy.val)<<1

//     int y = y_starti
//     SetPixel(x_starti, y_starti, get_color(255, 0, 0))
//     SetPixel(x_endi, y_endi, get_color(0, 255, 0))
//     for (var x = x_starti; x < x_endi; x++){
//         SetPixel(x, y, 0b1111111111111111)
//         // print(f'x = {x}, y = {y}')
//         // # If error integer is > 0, we need to increment y and
//         // # update error
//         if (error.s == 0){
//             y += 1
//             // error -= dx<<1
//             error = SubSignedInts(error, dxX2)
//         }         
//         // error += dy<<1
//         error = AddSignedInts(error, dyX2)
//     }
//     SetPixel(x_starti, y_starti, get_color(255, 0, 0))
//     SetPixel(x_endi, y_endi, get_color(0, 255, 0))
// }

void DrawLine(Float16 x1, Float16 y1, Float16 x2, Float16 y2, int color)
{
    // Draw endpoints
    SetPixel(x1, y1, get_color(255, 0, 0))
    SetPixel(x2, y2, get_color(0, 255, 0))


	Float16 xdiff = SubFloats(x2, x1)
	Float16 ydiff = SubFloats(y2, y1)

	if((xdiff == FLOAT_ZERO) && (ydiff == FLOAT_ZERO)) { // If the starting and ending points are the same
		SetPixel(FloatToInt(x1), FloatToInt(y1), color);
		return 0
	}

	if(CompareFloats(fabs(xdiff), fabs(ydiff), '>')) {
		Float16 xmin = FLOAT_ZERO
        Float16 xmax = FLOAT_ZERO

		// set xmin to the lower x value given
		// and xmax to the higher value
		if(CompareFloats(x1, x2, '<')) {
			xmin = x1
			xmax = x2
		} else {
			xmin = x2
			xmax = x1
		}

		// draw line in terms of y slope
		Float16 slope = DivFloats(ydiff, xdiff)
        write_float(slope)
		// for(float x = xmin; x <= xmax; x += 1.0f) {
		// 	float y = y1 + ((x - x1) * slope);
		// 	Color color = color1 + ((color2 - color1) * ((x - x1) / xdiff));
		// 	SetPixel(x, y, color);
		// }
	} else {
		Float16 ymin = FLOAT_ZERO
        Float16 ymax = FLOAT_ZERO

		// set ymin to the lower y value given
		// and ymax to the higher value
		if(CompareFloats(y1, y2, '<')) {
			ymin = y1
			ymax = y2
		} else {
			ymin = y2
			ymax = y1
		}

		// draw line in terms of x slope
		Float16 slope = DivFloats(xdiff, ydiff)
        // write('s')
        SetPixel(100, 100, get_color(0, 0, 255))
		// // for(float y = ymin; y <= ymax; y += 1.0f) { // Original
		// // 	float x = x1 + ((y - y1) * slope);
		// // 	Color color = color1 + ((color2 - color1) * ((y - y1) / ydiff));
		// // 	SetPixel(x, y, color);
		// // }
        Float16 y = ymin
		while(CompareFloats(y, ymax, '<')) {
			Float16 x = AddFloats(x1, MultFloats(SubFloats(y, y1), slope));
			// Color color = color1 + ((color2 - color1) * ((y - y1) / ydiff));
			SetPixel(FloatToInt(x), FloatToInt(y), color);
            y = AddFloats(y, ONE)
		}
	}
}

// https://gist.github.com/nowke/965fed0d5191bf373f1262be584207bb
void draw_line(int x1, int y1, int x2, int y2, int color) {
	SignedInt TWO = {s:0, val:2};

	SignedInt dx = {s:0, val:0};
	SignedInt dy = {s:0, val:0};
	// int i = 0
	SignedInt e = {s:0, val:0};
	
	SignedInt incx = {s:0, val:1};
	SignedInt incy = {s:0, val:1};
	SignedInt inc1 = {s:0, val:0};
	SignedInt inc2 = {s:0, val:0};
	
	SignedInt x = {s:0, val:x1};
	SignedInt y = {s:0, val:y1};

	// write_signed_int(x2)
	// write(',')
	// write_signed_int(x1)
	// write(' ')
	dx = SubSignedInts(x2,x)
	dy = SubSignedInts(y2,y)

	if (dx.s == 1) // If dx < 0
		dx.s = 0
	if (dy.s == 1)  // If dy < 0
		dy.s = 0

	if (x2 < x1)
		incx.s = 1

	if (y2 < y1)
		incy.s = 1

	// write_signed_int(dx)
	// write(',')
	// write_signed_int(dy)
		
	SetPixel(x1, y1, get_color(255, 0, 0))
	SetPixel(x2, y2, get_color(0, 255, 0))
	if (CompareSignedInts(dx, dy, '>')) {
		SetPixel(x, y, color)
		e = SubSignedInts(dy, dx)
		e = MultSignedInts(e, TWO)
		inc1 = SubSignedInts(dy, dx)
		inc1 = MultSignedInts(inc1, TWO)
		inc2 = MultSignedInts(dy, TWO)
		var maxval = dx.val
		for (var i=0; i<maxval; i++) {
			if (e.s == 0 || (e.s == 1 && e.val == 0)) { // if  e >= 0
				// y += incy
				y = AddSignedInts(y, incy)
				// e += inc1
				e = AddSignedInts(e, inc1)
				// newline()
				// write_signed_int(y)
			}
			else{
				// e += inc2
				e = AddSignedInts(e, inc2)
			}
			// x += incx
			x = AddSignedInts(x, incx)
			SetPixel(x, y, color)
		}

	} else {
		SetPixel(x, y, color)
		// e = 2*dx-dy
		e = MultSignedInts(dx, TWO)
		e = SubSignedInts(e, dy)
		// inc1 = 2*(dx-dy)
		inc1 = SubSignedInts(dx, dy)
		inc1 = MultSignedInts(inc1, TWO)
		// inc2 = 2*dx
		inc2 = MultSignedInts(dx, TWO)
		var maxval = dy.val
		for (var i = 0; i < maxval; i++) {
			if (e.s == 0 || (e.s == 1 && e.val == 0)) { // if  e >= 0
				// x += incx
				x = AddSignedInts(x, incx)
				// e += inc1
				e = AddSignedInts(e, inc1)
				// newline()
				// write_signed_int(x)
			}
			else{
				// e += inc2
				e = AddSignedInts(e, inc2)
			}
			// y += incy
			y = AddSignedInts(y, incy)
			int xval = x.val
			int yval = y.val
			SetPixel(xval, yval, color)
		}
	}
	// SetPixel(x1, y1, get_color(255, 0, 0))
	// SetPixel(x2, y2, get_color(0, 255, 0))
}


// bool ptInTriangle(int px, int py, int p0x, int p0y, int p1x, int p1y, int p2x, int p2y)
// {
//     var dX = px-p2x
//     var dY = py-p2y
//     var dX21 = p2x-p1x
//     var dY12 = p1y-p2y
//     var D = dY12*(p0x-p2x) + dX21*(p0y-p2y)
//     var s = dY12*dX + dX21*dY
//     var t = (p2y-p0y)*dX + (p0x-p2x)*dY
//     if (D<0)
//         return s<=0 && t<=0 && s+t>=D
//     return s>=0 && t>=0 && s+t<=D
// }

// /* A utility function to calculate area of triangle formed by (x1, y1),
//    (x2, y2) and (x3, y3) */
// int area(int x1, int y1, int x2, int y2, int x3, int y3)
// {
//    return (x1*(y2-y3) + x2*(y3-y1)+ x3*(y1-y2))/2
// }

// bool isInside(int x, int y, int x1, int y1, int x2, int y2, int x3, int y3)
// {  
//    /* Calculate area of triangle ABC */
//    int A = area(x1, y1, x2, y2, x3, y3)
  
//    /* Calculate area of triangle PBC */ 
//    int A1 = area(x, y, x2, y2, x3, y3)
  
//    /* Calculate area of triangle PAC */ 
//    int A2 = area(x1, y1, x, y, x3, y3)
  
//    /* Calculate area of triangle PAB */  
//    int A3 = area(x1, y1, x2, y2, x, y)
    
//    /* Check if sum of A1, A2 and A3 is same as A */
//    var sum = A1 + A2 + A3
//    return (A >= sum-(10)&&A <= sum+(10));
// }


int colorCount = 0
var colors = create_pointer(30000, 0)
colors[0] = get_color(255, 0, 0)
colors[1] = get_color(255, 255, 0)
colors[2] = get_color(0, 255, 255)
colors[3] = get_color(0, 255, 0)
colors[4] = get_color(255, 0, 255)
colors[5] = get_color(0, 0, 255)
while (true) {
    MouseInput input = expansionPorts[1];
    var offset = input.y * 108 + input.x;

    int xpos = input.x
    int ypos = input.y
    draw_line(54, 54, xpos, ypos, colors[colorCount])
	colorCount += 1
    // if (input.left == 1) {
    //     screen[offset] = get_color(255, 255, 255);
    // }
    // break
	if(colorCount >= 6)
		colorCount = 0
}

struct MouseInput {
    int y : 7;
    int x : 7;
    int left : 1;
    int right : 1;
};

// var chars = create_pointer(53546, 1)
// var offset = 0

// void write(int c) {
//     chars[offset] = c
//     offset++
// }

// void write_int(int value) {
//     var reverser = create_pointer(65530, 0)
//     var i = 0
//     for (var i = 0; i < 5; i++){
//         reverser[i] = 0
//     }
//     while (value > 0) {
//         var char = (value % 10) switch {
//             1 => '1',
//             2 => '2',
//             3 => '3',
//             4 => '4',
//             5 => '5',
//             6 => '6',
//             7 => '7',
//             8 => '8',
//             9 => '9',
//             _ => '0'
//         }

//         reverser[i] = char
//         value = value / 10
//         i += 1
//     }
//     for (var i = 0; i < 5; i++){
//         write(reverser[4-i])
//     }
// }

// write_int(area(3, 100, 54, 5, 100, 100))

// DrawLine(IntToFloat(10), IntToFloat(20), IntToFloat(60), IntToFloat(100), get_color(255, 255, 255))

// for (var x = 0; x < 108; x++) {
//     for (var y = 0; y < 108; y++) {
//         var screenOffset = (y * 108) + x
//         var pixel = 0
//         if(isInside(x, y, 3, 100, 54, 5, 100, 100)){
//             pixel = 65535
//         }
//         screen[screenOffset] = pixel
//         // // Delay
//         // for (var l = 0; l < 90 * 1; l++){
//         //     for (var o = 0; o < 1; o++){
//         //         // Do nothing  _(¦3」∠)_
//         //     }
//         // }
//     }
// }

// newline()
// SignedInt a = {s:0, val:70};
// SignedInt b = {s:1, val:10};
// var outint = AddSignedInts(a, b)
// write_signed_int(a)
// write('+')
// write_signed_int(b)
// write('=')
// write_signed_int(outint)


while (true){

}



//////////////////////////////////////////
//  This is all float and writing code: //
//////////////////////////////////////////


// var floats = create_pointer<Float16>(0x0, 1);
// var signedInts = create_pointer<SignedInt>(0x1111, 1);
// var screen = create_pointer(53871, 1)
// var charMem = create_pointer(53546, 1)
int offset = 0

var highlightColor = 0
var highlightOppositeColor = 0b1111111111111111


Float16 PI = { sign : 0, exponent : 0b10000, fraction : 0b1001001000 };
Float16 ONE = { sign : 0, exponent : 0b01111, fraction : 0 };

inline int get_color(int r, int g, int b) {
    return (r / 8 << 10) + (g / 8 << 5) + (b / 8);
}

int ClampInt(int x, int min, int max){
    if(x<min)
        return min
    else if(x>max)
        return max

    return x
}

// Function for drawing a single pixel to the screen
void SetPixel(int x, int y, int color){
    var screenOffset = (ClampInt(y, 0, 108) * 108) + ClampInt(x, 0, 108)
    screen[screenOffset] = color
}

void ChangeHighlightColor(int r, int g, int b){
    highlightColor = get_color(r, g, b)
    highlightOppositeColor = get_color(256-r, 256-g, 256-b)
}

void write(int c) {
    chars[offset] = c

    // Draw highlight behind character
    var pixOffsetY = (offset/18)*6
    var pixOffsetX = ((offset*6)%108)
    for (var x = 0; x < 6; x++) {
        for (var y = 0; y < 6; y++) {
            var pixel = highlightColor
            SetPixel(pixOffsetX+x, pixOffsetY+y, pixel)
        }
    }
    
    // Increment location offset by 1
    offset++
}

// Get the absolute value of a float value
Float16 fabs(Float16 f){
    Float16 outFloat = {sign:0, exponent:0, fraction:0};
    outFloat.exponent = f.exponent
    outFloat.fraction = f.fraction
    return outFloat
}

SignedInt IntToSignedInt(int x){
    SignedInt o = {s:0, val:x};
    return o
}

// void writeStr(int s) {
//     var size = sizeof(s)
//     for (var i = 0; i < size; i++) {
//         write(s[i])
//     }
// }

void newline(){
    offset = offset / 18 * 18 + 18
}

void write_int(int value) {
    var reverser = create_pointer(65530, 0)
    var i = 0
    for (var o = 0; o < 5; o++){
        reverser[o] = 0
    }
    while (value > 0) {
        var char = (value % 10) switch {
            1 => '1',
            2 => '2',
            3 => '3',
            4 => '4',
            5 => '5',
            6 => '6',
            7 => '7',
            8 => '8',
            9 => '9',
            _ => '0'
        }

        reverser[i] = char
        value = value / 10
        i += 1
    }
    bool atFirst = false
    for (var o = 0; o < 5; o++){
        // If the first non-zero number has finally been found, start writing number
        if(reverser[4-o] != 0)
            atFirst = true
        // Otherwise it is just a trailing zero, so skip
        else if(atFirst==false)
            continue
        write(reverser[4-o])
    }
}

void write_binary(int value) {
    var reverser = create_pointer(65519, 0)
    var i = 0
    for (var i = 0; i < 16; i++){
        reverser[i] = 0
    }
    while (value > 0) {
        var char = (value & 1) switch {
            1 => '1',
            _ => '0'
        }

        reverser[15-i] = char
        value = value >> 1
        i += 1
    }
    for (var i = 0; i < 16; i++){
        write(reverser[i])
    }
}

void write_float(Float16 f) {
    write('e')
    write(':')
    var exp = f.exponent
    write_binary(f.exponent)
    write('f')
    write(':')
    var frac = f.fraction
    write_binary(f.fraction)
}

void write_signed_int(SignedInt i) {
    if(i.s == true) // If negative, print `-`
        write('-')
    int v = i.val
    write_int(v)
}

int TruncateTrailingZeros(int x){
    var o = x
    for (var i = 0; i < 16; i++){
        // If the last digit is 1, then stop shifting
        if((o & 1) == 1)
            break
        // Otherwise shift again
        o = o >> 1
    }
    return o
}

// void write_float(Float16 value) {
//     if (value.sign == 1) {
//         write('-')
//     }

//     write_int(value.exponent)
//     write('.')
//     write_int(value.fraction)
// }

// Quadratic approximation of the sin function
Float16 sin(Float16 x){
    Float16 piSquared = MultFloats(PI, PI)
    Float16 four = IntToFloat(4)
    return MultFloats((DivFloats(MultFloats(four,x), piSquared)),SubFloats(PI,x))
}

// Returns true if values a and b are within +-range of eachother
bool WithinRange(SignedInt aI, SignedInt bI, int range){
    var a = aI.val
    var b = bI.val
    if(a > b){
        if((a-b)<=range){
            // write_int(a-b)
            return true
        }
        else{
            return false
        }
    }
    else if(a < b){
        if((b-a)<=range){
            // write_int(b-a)
            return true
        }
        else{
            return false
        }
    }
    return true
}

int Delta(int a, int b){
    if(a > b)
        return a - b
    else if(a < b)
        return b - a
    
    return 0
}

// Temporary bitwise not ~ operator function, since currently that operator
// is broken and only returns 0 unless used like this:
int NOT(int x){
    return ~x&0b1111111111111111
}

// Convert integer to it's negative value in twos complement
int Negative(int x){
    return NOT(x) + 1
}

inline int XOR(int a, int b){
    return (a|b)&(NOT(a&b))
}


int get_shift_amnt(int man, int exp){
    return 10-exp
}

// string DecimalToBinaryString(int a)
// {
//     uint b = (uint)a
//     string binary = ""
//     uint mask = 0x80000000u
//     while (mask > 0)
//     {
//         binary += ((b & mask) == 0) ? '0' : '1'
//         mask >>= 1
//     }
//     return binary
// }

// Returns the integer base raised to the power integer exponent
int pow(int base, SignedInt exponent){
    var calculated = base
    // If the exponent is negative, we divide each time instead of multiply
    if(exponent.s == 1){
        for (var i = 1; i < exponent.val; i++){
            calculated = calculated / base
        }
    }
    // Otherwise it is normal multiplication exponent
    else {
        for (var i = 1; i < exponent.val; i++){
            calculated = calculated * base
        }
    }
    return calculated
}

// Adjust a float so that the 11th bit in the mantissa is 1, the whole number
Float16 normalizeFloat(int fraction, int exponent){
    var frac = fraction
    var exp = exponent
    // If the 11th digit is already the whole number 1
    if((frac & 0b1111100000000000) == 0 && (frac & 0b10000000000) == 0b10000000000){
        exp += 1
    }
    else{
        // If leftmost digit is further than mantissa max of 10, then shift right
        for (var j = 0; j < 10; j++){
            // If the left has no 1s, then stop shifting
            if((frac & 0b1111100000000000) == 0)
                break
            // Otherwise shift again
            frac = frac >> 1
            exp += 1
        }
        // Shift left until 11th digit is 1
        for (var i = 0; i < 12; i++){
            // If the left digit is 1, then stop shifting
            if((frac & 0b10000000000) == 0b10000000000)
                break
            // Otherwise shift again
            frac = frac << 1
            exp -= 1
        }
    }
    frac = frac&0b1111111111
    Float16 outFloat = { sign : 0, exponent : exp, fraction : frac };
    return outFloat
}

int deNormalizeFraction(int f, int exp){
    bool sn = (10-exp>60000)
    var vl = 10-exp
    // SignedInt powNum = { s : 0, val : 0 };
    if (sn){
        vl = 65535-(10-exp)
        // powNum.s = 1
    }
    // powNum.val = vl


    // return (f * pow(2, powNum))
    // If negative
    if(sn == 1){
        return f<<vl
    }
    // Otherwise shift normal way
    else{
        return f>>vl
    }
}

SignedInt AddSignedInts(SignedInt a, SignedInt b){
    SignedInt outInt = {s: 0, val:0};

    // If the signs are the same, just add and return that same sign
    if(a.s == b.s){
        outInt.s = a.s
        outInt.val = (a.val+b.val)
    }
    // Else if the signs are different and a is negative while b is positive, subtract a from b (b-a)
    else if(a.s == 1){
        // If the value of A is bigger than the value of B, then that means subtracting will make B negative
        if(a.val > b.val){
            outInt.s = 1
            outInt.val = a.val-b.val
        }
        else{
            outInt.val = b.val-a.val
        }

        // outInt.val = Delta(a.val,b.val)
    }
    // Else if the signs are different and b is negative while a is positive, subtract b from a (a-b)
    else if(b.s == 1){
        // If the value of B is bigger than the value of A, then that means subtracting will make A negative
        if(b.val > a.val){
            outInt.s = 1
            outInt.val = b.val-a.val
        }
        else{
            outInt.val = a.val-b.val
        }

        // outInt.val = Delta(b.val,a.val)
    }

    return outInt
}


// SignedInt a = {s:1, val:13};
// SignedInt b = {s:1, val:14};
// var outint = MultSignedInts(a, b)
// write_signed_int(a)
// write('*')
// write_signed_int(b)
// write('=')
// write_signed_int(outint)

// SignedInt a = {s:1, val:13};
// SignedInt b = {s:1, val:14};
// var comp = '>'
// var outint = CompareSignedInts(a, b, comp)
// write_signed_int(a)
// write('>')
// write_signed_int(b)
// write('=')
// if(outint){
//     write('t')
//     write('r')
//     write('u')
//     write('e')
// }
// else{
//     write('f')
//     write('a')
//     write('l')
//     write('s')
//     write('e')
// }


SignedInt SubSignedInts(SignedInt a, SignedInt b){
    // Invert b's sign bit
    SignedInt bInt = b
    bInt.s = !bInt.s

    SignedInt outInt = AddSignedInts(a, bInt);

    return outInt
}

SignedInt MultSignedInts(SignedInt a, SignedInt b){
    // Determine final sign, if they are different it is 1, if they are both 0 it is 0, and if they are both 1 it is also 0
    var finalSign = 0
    if(a.s != b.s)
        finalSign = 1

    var finalVal = a.val*b.val
    SignedInt outInt = {s:finalSign, val:finalVal};

    return outInt
}

// Subtract two ints, and return a signed int to allow for negative numbers
SignedInt SubToSignedInt(int a, int b){
	var aval = a
	var bval = b
    // Convert each to a signed int
    SignedInt aInt = {s:0, val:aval};
    SignedInt bInt = {s:0, val:bval}; // Invert b's sign

	SignedInt outInt = {s:0, val:0};
    outInt = AddSignedInts(aInt, bInt);

    return outInt
}

SignedInt Signed(int a){
    SignedInt outInt = {s: 0, val:a};
    return outInt
}

SignedInt NegativeSigned(int a){
    SignedInt outInt = {s: 1, val:a};
    return outInt
}

// Return the integer rounded approximation of a float
int FloatToUnsignedInt(Float16 fl){
    var tmpF = fl.fraction + 0b10000000000

    var tmpE = fl.exponent - 15

    var ouval = deNormalizeFraction(tmpF, tmpE) // Int version

    return ouval
}

// Return the signed integer rounded approximation of a float
SignedInt FloatToInt(Float16 fl){
    var tmpF = fl.fraction + 0b10000000000
    // tmpF = TruncateTrailingZeros(tmpF)

    var tmpE = fl.exponent - 15

    var si = fl.sign

    // int out = tmpF >> get_shift_amnt(tmpF, tmpE)

    var ouval = deNormalizeFraction(tmpF, tmpE) // Int version

    SignedInt out = { s:si, val:ouval }; // Add correct sign

    return out
}

bool CompareSignedInts(SignedInt a, SignedInt b, int comp){
    int compresult = 0 // This stores the result of the comparison, 0 is for equal, 1 is if a > b, and 2 is if a < b

    // If a is negative and b is not it is only less than
    if(a.s > b.s){
        compresult = 2
    }
    // If b is negative and a is not it is only greater than
    else if(a.s < b.s){
        compresult = 1
    }
    // If the signs are both negative, check each absolute value
    //   (since we are negative, a greater magnitude means a lower number)
    else if(a.s == 1){
        // If the values are the same
        if(a.val == b.val){
            compresult = 0
        }
        // If a is greater than b
        else if(a.val > b.val){
            compresult = 2
        }
        // If b is greater than a
        else if(a.val < b.val){
            compresult = 1
        }
    }
    // If the signs are both positive, check each absolute value
    else if(a.s == 0){
        // If the values are the same
        if(a.val == b.val){
            compresult = 0
        }
        // If a is greater than b
        else if(a.val > b.val){
            compresult = 1
        }
        // If b is greater than a
        else if(a.val < b.val){
            compresult = 2
        }
    }
    

    // Now that the actual comparision is done, return a true or false based upon what we are looking for in `comp`
    if(comp == '='){ // Equal
        if(compresult == 0)
            return true
    }
    else if(comp == '>'){ // Greater
        if(compresult == 1)
            return true
    }
    else if(comp == '<'){ // Less
        if(compresult == 2)
            return true
    }

    return false
}

bool CompareFloats(Float16 a, Float16 b, int comp){
    int compresult = 0 // This stores the result of the comparison, 0 is for equal, 1 is if a > b, and 2 is if a < b

    // If a is negative and b is not it is only less than
    if(a.sign > b.sign){
        compresult = 2
    }
    // If b is negative and a is not it is only greater than
    else if(a.sign < b.sign){
        compresult = 1
    }
    // If the signs are both negative, check each absolute value
    //   (since we are negative, a greater magnitude means a lower number)
    else if(a.sign == 1){
        // If the exponents are the same, compare mantisssas
        if(a.exponent == b.exponent){
            // If they are the same, then these values are equal
            if(a.fraction == b.fraction){
                compresult = 0
            }
            // Else if a mantissa is greater than b
            else if(a.fraction > b.fraction){
                compresult = 2 // A greater mantissa means a lower negative number
            }
            // Else if b mantissa is greater than a
            else if(b.fraction > a.fraction){
                compresult = 1
            }
        }
        // If a is greater than b
        else if(a.exponent > b.exponent){
            compresult = 2
        }
        // If b is greater than a
        else if(a.exponent < b.exponent){
            compresult = 1
        }
    }
    // If the signs are both positive, check each absolute value
    else if(a.sign == 0){
        // If the exponents are the same, compare mantisssas
        if(a.exponent == b.exponent){
            // If they are the same, then these values are equal
            if(a.fraction == b.fraction){
                compresult = 0
            }
            // Else if a mantissa is greater than b
            else if(a.fraction > b.fraction){
                compresult = 1
            }
            // Else if b mantissa is greater than a
            else if(b.fraction > a.fraction){
                compresult = 2
            }
        }
        // If a is greater than b
        else if(a.exponent > b.exponent){
            compresult = 1
        }
        // If b is greater than a
        else if(a.exponent < b.exponent){
            compresult = 2
        }
    }
    

    // Now that the actual comparision is done, return a true or false based upon what we are looking for in `comp`
    if(comp == '='){ // Equal
        if(compresult == 0)
            return true
    }
    else if(comp == '>'){ // Greater
        if(compresult == 1)
            return true
    }
    else if(comp == '<'){ // Less
        if(compresult == 2)
            return true
    }

    return false
}

// Return the integer rounded approximation of a float
Float16 IntToFloat(SignedInt x){
    // Find the exponent, by shifting left until the largest digit is reached
    var count = 1
    var tmp = x.val
    var mask = 1
    for (var i = 0; i < 16; i++){
        // If the first digit is 1, then stop shifting because we have the count
        if((tmp & 0b1000000000000000) == 0b1000000000000000)
            break
        // Otherwise shift again
        tmp = tmp << 1
        count += 1
    }
    // Get exponent from count, then add offset of 15 for float format
    var exp = (15-count)+15
    
    var mant = x.val
    // If the mantissa is >= 10 bits long already, only use first 10
    if(mant > 0b11111111111){
        mant = mant >> ((16-count)-11)
    }
    else if(mant < 0b10000000000){
        mant = mant << (11-(16-count))
    }

    Float16 outFloat = normalizeFloat(mant, exp);
    outFloat.sign = x.s

    return outFloat
}

Float16 AddFloats(Float16 floatA, Float16 floatB){
    Float16 outFloat = { sign : 0, exponent : 0, fraction : 0 };
    // If the exponents are different, then we need to make the float with the smaller exponent the same as the larger one
    if(floatA.exponent > floatB.exponent){
        var tmpMB = ((floatB.fraction+0b10000000000)>>(floatA.exponent-floatB.exponent))
        var tmpMA = floatA.fraction+0b10000000000

        bool finalSign = false
        if(floatB.sign == true){
            tmpMB = Negative(tmpMB)
            // Determine the final sign, it is 1 if B is > A
            if(floatB.exponent > floatA.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatB.exponent == floatA.exponent) && (floatB.fraction > floatA.fraction))
                finalSign = true
        }
        if(floatA.sign == true){
            tmpMA = Negative(tmpMA)
            // Determine the final sign, it is 1 if A is > B
            if(floatA.exponent > floatB.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatA.exponent == floatB.exponent) && (floatA.fraction > floatB.fraction))
                finalSign = true
        }
        
        int tmpM = tmpMA+tmpMB
        int exp = floatA.exponent
        outFloat = { sign : finalSign, exponent : exp, fraction : tmpM };
        if ((tmpM & 0b10000000000) != 0b10000000000) // If the 11th bit is 0, then normalize
            outFloat = normalizeFloat(tmpM, exp)
    }
    // 150+500
    else if(floatA.exponent < floatB.exponent){
        int tmpMB = floatB.fraction+0b10000000000
        int tmpMA = ((floatA.fraction+0b10000000000)>>(floatB.exponent-floatA.exponent))
        
        bool finalSign = false
        if(floatB.sign == true){
            tmpMB = Negative(tmpMB)
            // Determine the final sign, it is 1 if B is > A
            if(floatB.exponent > floatA.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatB.exponent == floatA.exponent) && (floatB.fraction > floatA.fraction))
                finalSign = true
        }
        if(floatA.sign == true){
            tmpMA = Negative(tmpMA)
            // Determine the final sign, it is 1 if A is > B
            if(floatA.exponent > floatB.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatA.exponent == floatB.exponent) && (floatA.fraction > floatB.fraction))
                finalSign = true
        }
        
        int tmpM = tmpMA+tmpMB
        
        int exp = floatB.exponent
        outFloat = { sign : finalSign, exponent : exp, fraction : tmpM };
        if ((tmpM & 0b10000000000) != 0b10000000000) // If the 11th bit is 0, then normalize
            outFloat = normalizeFloat(tmpM, floatB.exponent)
    }
    // Else the exponents are the same, so no need to change them
    else {
        int tmpMB = (floatB.fraction+0b10000000000)>>1
        int tmpMA = (floatA.fraction+0b10000000000)>>1
        
        bool finalSign = false
        if(floatB.sign == true){
            tmpMB = Negative(tmpMB)
            // Determine the final sign, it is 1 if B is > A
            if(floatB.exponent > floatA.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatB.exponent == floatA.exponent) && (floatB.fraction > floatA.fraction))
                finalSign = true
        }
        if(floatA.sign == true){
            tmpMA = Negative(tmpMA)
            // Determine the final sign, it is 1 if A is > B
            if(floatA.exponent > floatB.exponent)
                finalSign = true
            // If they have the same exponent, check mantissas as well
            else if((floatA.exponent == floatB.exponent) && (floatA.fraction > floatB.fraction))
                finalSign = true
        }
        
        int tmpM = tmpMA+tmpMB
        
        int exp = floatB.exponent+1
        outFloat = { sign : finalSign, exponent : exp, fraction : tmpM };
        if ((tmpM & 0b10000000000) != 0b10000000000) // If the 11th bit is 0, then normalize
            outFloat = normalizeFloat(tmpM, floatB.exponent)
    }

    return outFloat
}

Float16 SubFloats(Float16 floatA, Float16 floatB){
    Float16 fb = floatB
    fb.sign = !fb.sign
    return AddFloats(floatA, fb)
}


Float16 MultFloats(Float16 floatA, Float16 floatB){
    int tmpMA = floatA.fraction+0b10000000000
    int tmpMB = floatB.fraction+0b10000000000

    int snA = floatA.sign
    int snB = floatB.sign

    // Determine final sign, if they are different it is 1, if they are both 0 it is 0, and if they are both 1 it is also 0
    var finalSign = 0
    if(snA != snB)
        finalSign = 1

    // Get the lowest bit that is 1 in either A or B
    var count = 0 // count is for the lowest index there is a 1
    for (var i = 0; i < 16; i++){
        // If the lowest bit in A or B is 1, stop the loop
        if(((tmpMA & 1) == 1) || ((tmpMB & 1) == 1))
            break
        else{
            // Shift right
            tmpMA = tmpMA >> 1
            tmpMB = tmpMB >> 1
            count += 1
        }
    }
    
    int tmpM = tmpMA*tmpMB
    int exp = floatA.exponent+floatB.exponent-15+count-4
    
    Float16 outFloat = { sign : finalSign, exponent : exp, fraction : tmpM };
    if ((tmpM & 0b10000000000) != 0b10000000000) // If the 11th bit is 0, then normalize
        outFloat = normalizeFloat(tmpM, exp)

    return outFloat
}

// Credit to njuffa (https://cs.stackexchange.com/users/51535/njuffa),
// "Simple algorithm for IEEE-754 division on 8-bit CPU?"",
// URL (version: 2019-02-28): https://cs.stackexchange.com/q/104961
Float16 DivFloats (Float16 a, Float16 b)
{
    int r = 0
    int x = 0
    int y = 0
    int sign = 0

    int expo_x = 0
    int expo_y = 0

    int i = 0
    int odd = 0
    int rnd = 0
    int sticky = 0

    Float16 outVal = {sign:0, exponent:0, fraction:0};

    /* extract biased exponents and sign bits */
    expo_x = a.exponent
    expo_y = b.exponent
    sign = XOR(a.sign, b.sign)

    var processNow = false

    for (var jj = 0; jj < 2; jj++){
        if (((expo_x >= 1) && (expo_x <= 0b11110) &&
            (expo_y >= 1) && (expo_y <= 1)) || processNow) { /* fast path */
    // divide:
            /* add significand leading 1 int */
            x = a.fraction + 0b10000000000
            y = b.fraction + 0b10000000000
            /* compute exponent of result */
            outVal.exponent = expo_x - expo_y + 15
            /* dividend may not be smaller than divisor: normalize */
            if (x < y) {
                x = x << 1
                outVal.exponent -= 1
            }
            /* generate quotient one bit at at time */
            r = 0
            for (i = 0; i < 12; i++) {
                r = r << 1
                if (x >= y) {
                    x = x - y
                    r = r | 1
                }
                x = x << 1
            }
            /* OR remainder bits into sticky bit */
            sticky = (x != 0)
            if ((outVal.exponent >= 1) && 
                (outVal.exponent <= 0b11110)) { /* normal, may overflow to infinity*/
                /* extract round and lsb bits */
                rnd = (r & 1)
                odd = (r & 2) != 0
                /* remove round bit from quotient and round to-nearest-even */
                r = (r >> 1) + (rnd & (sticky | odd))
                /* set significand */
                outVal.fraction = r - 0b10000000000
            } else if (outVal.exponent > 0b11110) { // overflow: infinity
                outVal.exponent = 0b011111
            } else { /* underflow: result is zero, subnormal, or smallest normal */
                int shift = (1 - outVal.exponent)
                /* clamp shift count */
                if (shift > 12) shift = 12
                /* OR shifted-off bits of significand into sticky bit */
                sticky = sticky | ((r & NOT(NOT(0) << shift)) != 0)
                /* denormalize significand */
                r = r >> shift
                /* extract round and lsb bits */
                rnd = (r & 1)
                odd = (r & 2) != 0
                /* remove round bit from quotient and round to-nearest-even */
                // r = (r >> 1) + (rnd & (sticky | odd));
                outVal.fraction = (r >> 1) + (rnd & (sticky | odd))
            }
            // /* combine sign bit with combo of exponent and significand */
            // r = r | sign;
            outVal.sign = sign
        } else { /* slow path */
            // /* take absolute value of arguments */
            // x = a & NOT(SIGN_MASK);
            // y = b & NOT(SIGN_MASK);
            /* if dividend is a NaN, convert that NaN into a QNaN and return it */
            if ((a.exponent == 0b11111) && (a.fraction > 0)){
                outVal.sign = a.sign
                outVal.fraction = a.fraction | 0b1000000000
                outVal.exponent = a.exponent
                return outVal
            }
            /* if divisor is a NaN, convert that NaN into a QNaN and return it */
            if ((b.exponent == 0b11111) &&(b.fraction > 0)){
                outVal.sign = b.sign
                outVal.fraction = b.fraction | 0b1000000000
                outVal.exponent = b.exponent
                return outVal
            }
            /* dividend and divisor are both zero or infinity: invalid operation */
            if (((a.exponent == 0 && a.fraction == 0) && (b.exponent == 0 && b.fraction == 0)) || 
                ((a.exponent == 0b11111) && (b.exponent == 0b11111)))
            {
                outVal.sign = 1
                outVal.fraction = 0b1000000000
                outVal.exponent = 0b11111
                return outVal
            }
            /* 0/y or x/INF -> 0 */
            if ((a.exponent == 0 && a.fraction == 0) || (a.exponent == 0b11111))
            {
                outVal.sign = sign
                return outVal
            }
            /* x/0 or INF/y -> INF */
            if ((b.exponent == 0 && b.fraction == 0) || (a.exponent == 0b11111))
            {
                outVal.sign = sign
                outVal.fraction = 0
                outVal.exponent = 0b11111
                return outVal
            }
            /* if dividend is a subnormal, normalize it */
            if (expo_x == 0) {
                expo_x += 1
                int afrac = a.fraction
                for (var afs = 0; afs < 16; afs++){
                    if((afrac & 0b10000000000)==0b10000000000)
                        break
                    afrac = afrac << 1
                    expo_x -= 1
                }
                a.fraction = afrac
            }
            /* if divisor is a subnormal, normalize it */
            if (expo_y == 0) {
                expo_y += 1
                int bfrac = b.fraction
                for (var bs = 0; bs < 16; bs++){
                    if((bfrac & 0b10000000000)==0b10000000000)
                        break
                    bfrac = bfrac << 1
                    expo_y -= 1
                }
                b.fraction = bfrac
            }
            /* now that dividend and divisor are normalized, do the division */
            // goto divide
            processNow = true
        }
    }
    
    return outVal
}


// /////////////////////////
// // These are the tests //
// /////////////////////////

// ChangeHighlightColor(0, 0, 200)
// write('f')
// write('l')
// write('o')
// write('a')
// write('t')
// write(' ')
// write('t')
// write('e')
// write('s')
// write('t')
// write('s')
// write(':')
// newline()

// // // herethisis:
// // var valu = 0b1000000001
// // newline()
// // write_binary(valu)
// // valu = valu^0b1100000001
// // newline()
// // write_binary(valu)
// // // goto herethisis


// // Float16 f16 = { sign : 1, exponent : 5, fraction : 10 };
// // write_int(f16.exponent)
// SignedInt correctVal = {s:0, val:0};
// SignedInt val = {s:0, val:0};
// // write_signed_int(RetSame(val))

// // t1: Float to int 1022
// correctVal = {s:0, val:1022};
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('1')
// write(' ')
// Float16 inValue = IntToFloat(correctVal);
// val = FloatToInt(inValue)
// // newline()
// // write_float(inValue)
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()

// // t2: Float to int 2751
// correctVal = {s:0, val:2751};
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('2')
// write(' ')
// Float16 inValue = IntToFloat(correctVal);
// val = FloatToInt(inValue)
// // newline()
// // write_float(inValue)
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()
// // write_binary(val) // Binary should be: 0000000010100000

// // // t2: Add floats 160 + 160 = 320
// // correctVal = 320
// // ChangeHighlightColor(0, 128, 128)
// // write('t')
// // write('2')
// // write(' ')
// // Float16 t2a = { sign : 0, exponent : 0b10110, fraction : 0b0100000000 };
// // Float16 t2b = { sign : 0, exponent : 0b10110, fraction : 0b0100000000 };
// // val = AddFloats(t2a, t2b)
// // if(WithinRange(correctVal, val, 10) == false)
// //     ChangeHighlightColor(230, 0, 0)
// // else
// //     ChangeHighlightColor(0, 230, 0)
// // write_int(val)
// // write(' ')
// // ChangeHighlightColor(128, 128, 0)
// // write_int(correctVal)
// // ChangeHighlightColor(0, 128, 128)
// // newline()
// // newline()

// // t3: Add floats 150 + 500 = 650
// SignedInt AVal = {s:0, val:150};
// SignedInt BVal = {s:0, val:500};
// correctVal = {s:0, val:(AVal.val+BVal.val)};
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('3')
// write(' ')
// Float16 inValueA = IntToFloat(AVal);
// write_signed_int(FloatToInt(inValueA))
// Float16 inValueB = IntToFloat(BVal);
// write('+')
// write_signed_int(FloatToInt(inValueB))
// val = FloatToInt(AddFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write('=')
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)

// // t4: Add floats 700 + 140 = 840
// SignedInt AVal = {s:0, val:700};
// SignedInt BVal = {s:0, val:140};
// correctVal = {s:0, val:(AVal.val + BVal.val)};
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('4')
// write(' ')
// Float16 inValueA = IntToFloat(AVal);
// write_signed_int(FloatToInt(inValueA))
// Float16 inValueB = IntToFloat(BVal);
// write('+')
// write_signed_int(FloatToInt(inValueB))
// val = FloatToInt(AddFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write('=')
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)

// // t5: Add floats 3000 + -7000 = -4000
// SignedInt AVal = {s:0, val:3000};
// SignedInt BVal = {s:1, val:7000};
// correctVal = {s:0, val:(AVal.val - BVal.val)};
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('5')
// write(' ')
// Float16 inValueA = IntToFloat(AVal);
// write_signed_int(FloatToInt(inValueA))
// Float16 inValueB = IntToFloat(BVal);
// write('+')
// write_signed_int(FloatToInt(inValueB))
// val = FloatToInt(AddFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write('=')
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()

// // t6: Multiply floats 50 * 4 = 200
// SignedInt AVal = {s:0, val:50};
// SignedInt BVal = {s:0, val:4};
// correctVal = {s:0, val:(AVal.val*BVal.val)};
// write('t')
// write('6')
// write(' ')
// Float16 inValueA = IntToFloat(AVal);
// Float16 inValueB = IntToFloat(BVal);
// val = FloatToInt(MultFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()

// // t7: Multiply floats 17 * 0.5 = 8.5
// SignedInt AVal = {s:0, val:17};
// correctVal = {s:0, val:(AVal.val/2)};
// write('t')
// write('7')
// write(' ')
// Float16 inValueA = IntToFloat(AVal);
// Float16 inValueB = { sign : 0, exponent : 0b01110, fraction : 0 };
// val = FloatToInt(MultFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()

// // t8: Subtract floats 140 - 37 = 107
// SignedInt AVal = {s:0, val:140};
// SignedInt BVal = {s:0, val:37};
// correctVal = {s:0, val:(AVal.val-BVal.val)};
// write('t')
// write('8')
// write(' ')
// Float16 inValueA = IntToFloat(AVal);
// Float16 inValueB = IntToFloat(BVal);
// val = FloatToInt(SubFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()
// // write_binary(val)
// // newline()

// // t9: Divide floats 70 / 24 = 80
// SignedInt AVal = {s:0, val:70};
// // SignedInt BVal = {s:0, val:3};
// correctVal = {s:0, val:116};
// write('t')
// write('9')
// write(' ')
// Float16 inValueA = IntToFloat(AVal);
// Float16 inValueB = {sign:0, fraction:0b0011001100, exponent:0b01110};
// val = FloatToInt(DivFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()


// // tx: Divide floats 10 / 2 = 5
// SignedInt AVal = {s:0, val:10};
// SignedInt BVal = {s:0, val:2};
// correctVal = {s:0, val:(AVal.val/BVal.val)};
// write('t')
// write('x')
// write(' ')
// Float16 inValueA = IntToFloat(AVal);
// Float16 inValueB = IntToFloat(BVal);
// val = FloatToInt(DivFloats(inValueA, inValueB))
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_signed_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_signed_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()

// // t5: Float to int 1.7
// write('t')
// write('5')
// write(' ')
// Float16 t5 = { sign : 0, exponent : 0b01111, fraction : 0b1011001100 };
// val = FloatToInt(t5)
// write_int(val)
// newline()
// newline()

// // t6: Int to Float to int 0 through 10000
// write('t')
// write('6')
// write(' ')
// // Iterate through all values 0 through 10000, and count the number of incorrect
// var numWrong = 0
// var startWrong = 0
// var endWrong = 0
// for (var i = 0; i < 10000; i++){
//     correctVal = i
//     Float16 t6 = IntToFloat(correctVal);
//     // t6 = normalizeFloat(t6.fraction, t6.exponent)
//     // Float16 t6 = { sign : 0, exponent : 0b10100, fraction : 0b0010000000 };
//     val = FloatToInt(t6)
//     if(WithinRange(correctVal, val, 10) == false){
//         numWrong += 1
//         if(startWrong==0)
//             startWrong = i

//         endWrong = i
//         // write_int(i)
//         // break
//     }
// }
// write(' ')
// write('w')
// write('r')
// write('o')
// write('n')
// write('g')
// write(':')
// write(' ')
// ChangeHighlightColor(128, 0, 128)
// if(numWrong > 0)
//     write_int(numWrong)
// else{
//     ChangeHighlightColor(0, 230, 0)
//     write('n')
//     write('o')
//     write('n')
//     write('e')
// }
// newline()
// ChangeHighlightColor(0, 128, 128)
// write('s')
// write('t')
// write('a')
// write(':')
// write(' ')
// write_int(startWrong)
// newline()
// write('e')
// write('n')
// write('d')
// write(':')
// write(' ')
// write_int(endWrong)
// newline()


//cout << DecimalToBinaryString(val) << " : " << val << endl

//    cout << "Float To Int: 13.78" <<endl;
//    val = FloatToInt(0, 0b10010, 0b1011100011);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Float To Int: 2100" <<endl;
//    val = FloatToInt(0, 0b11010, 0b0000011010);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Float To Int: 3.141" <<endl;
//    val = FloatToInt(0, 0b10000, 0b1001001000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Add floats: 3.141 + 20 = 23.141" <<endl;
//    val = AddFloats(0, 0b10000, 0b1001001000, 0, 0b10011, 0b0100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Add floats: 281 + 425.5 = 706.5" <<endl;
//    val = AddFloats(0, 0b10111, 0b0001100100, 0, 0b10111, 0b1010100110);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Sub floats: 800 - 425.5 = 374.5" <<endl;
//    val = SubFloats(0, 0b11000, 0b1001000000, 0, 0b10111, 0b1010100110);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 15 * 3.5 = 52.5" <<endl;
//    val = MultFloats(0, 0b10010, 0b1110000000, 0, 0b10000, 0b1100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 300 * 3.5 = 1050" <<endl;
//    val = MultFloats(0, 0b10111, 0b0010110000, 0, 0b10000, 0b1100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 300 * 0.5 = 150" <<endl;
//    val = MultFloats(0, 0b10111, 0b0010110000, 0, 0b01110, 0b0000000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 0.5 * 0.5 = 0.25" <<endl;
//    val = MultFloats(0, 0b01110, 0b0000000000, 0, 0b01110, 0b0000000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

// while (true) {
    
// }


struct Float16 {
    int sign : 1
    int exponent : 5
    int fraction : 10
}

struct SignedInt {
    int val : 15
    bool s : 1
}
