
var floats = create_pointer<Float16>(0x3FFE);
var signedInts = create_pointer<SignedInt>(0x4000);
var screen = create_pointer(53871, 1)
var chars = create_pointer(53546, 1)
var offset = 0

var highlightColor = 0
var highlightOppositeColor = 255


Float16 PI = { sign : 0b0, exponent : 0b10000, fraction : 0b1001001000 };

inline int get_color(int r, int g, int b) {
    return (r / 8 << 10) + (g / 8 << 5) + (b / 8);
}

// Function for drawing a single pixel to the screen
void SetPixel(int x, int y, int color){
    var screenOffset = (y * 108) + x
    screen[screenOffset] = color
}

void ChangeHighlightColor(int r, int g, int b){
    highlightColor = get_color(r, g, b)
    highlightOppositeColor = get_color(256-r, 256-g, 256-b)
}

void write(int c) {
    chars[offset] = c

    // Draw highlight behind character
    var pixOffsetY = (offset/18)*6
    var pixOffsetX = ((offset*6)%108)
    for (var x = 0; x < 6; x++) {
        for (var y = 0; y < 6; y++) {
            var pixel = highlightColor
            SetPixel(pixOffsetX+x, pixOffsetY+y, pixel)
        }
    }
    
    // Increment location offset by 1
    offset++
}

// Get the absolute value of a float value
Float16 fabs(Float16 f){
    f.sign = 0
    return f
}

SignedInt IntToSignedInt(int x){
    SignedInt o = {s:0, val:x};
    return o
}

// void writeStr(int s) {
//     var size = sizeof(s)
//     for (var i = 0; i < size; i++) {
//         write(s[i])
//     }
// }

void newline(){
    offset = offset / 18 * 18 + 18
}

void write_int(int value) {
    var reverser = create_pointer(65530, 0)
    var i = 0
    for (var o = 0; o < 5; o++){
        reverser[o] = 0
    }
    while (value > 0) {
        var char = (value % 10) switch {
            1 => '1',
            2 => '2',
            3 => '3',
            4 => '4',
            5 => '5',
            6 => '6',
            7 => '7',
            8 => '8',
            9 => '9',
            _ => '0'
        }

        reverser[i] = char
        value = value / 10
        i += 1
    }
    bool atFirst = false
    for (var o = 0; o < 5; o++){
        // If the first non-zero number has finally been found, start writing number
        if(reverser[4-o] != 0)
            atFirst = true
        // Otherwise it is just a trailing zero, so skip
        else if(atFirst==false)
            continue
        write(reverser[4-o])
    }
}

void write_binary(int value) {
    var reverser = create_pointer(65519, 0)
    var i = 0
    for (var i = 0; i < 16; i++){
        reverser[i] = 0
    }
    while (value > 0) {
        var char = (value & 1) switch {
            1 => '1',
            _ => '0'
        }

        reverser[15-i] = char
        value = value >> 1
        i += 1
    }
    for (var i = 0; i < 16; i++){
        write(reverser[i])
    }
}

void write_float(Float16 f) {
    write('e')
    write(':')
    var exp = f.exponent
    write_binary(f.exponent)
    write('f')
    write(':')
    var frac = f.fraction
    write_binary(f.fraction)
}

int TruncateTrailingZeros(int x){
    var o = x
    for (var i = 0; i < 16; i++){
        // If the last digit is 1, then stop shifting
        if((o & 1) == 1)
            break
        // Otherwise shift again
        o = o >> 1
    }
    return o
}

// void write_float(Float16 value) {
//     if (value.sign == 1) {
//         write('-')
//     }

//     write_int(value.exponent)
//     write('.')
//     write_int(value.fraction)
// }

// Quadratic approximation of the sin function
//Float16 sin(Float16 x){
//  return ((4*x)/pow(PI, 2))*(PI-x)
//}

// Returns true if values a and b are within +-range of eachother
bool WithinRange(int a, int b, int range){
    if(a > b){
        if((a-b)<=range){
            // write_int(a-b)
            return true
        }
        else{
            return false
        }
    }
    else if(a < b){
        if((b-a)<=range){
            // write_int(b-a)
            return true
        }
        else{
            return false
        }
    }
    return true
}


int Negative(int x){
    return ((~x)+1)
}


int get_shift_amnt(int man, int exp){
    return 10-exp
}

// string DecimalToBinaryString(int a)
// {
//     uint b = (uint)a
//     string binary = ""
//     uint mask = 0x80000000u
//     while (mask > 0)
//     {
//         binary += ((b & mask) == 0) ? '0' : '1'
//         mask >>= 1
//     }
//     return binary
// }

// Returns the integer base raised to the power integer exponent
int pow(int base, SignedInt exponent){
    var calculated = base
    // If the exponent is negative, we divide each time instead of multiply
    if(exponent.s == 1){
        for (var i = 1; i < exponent.val; i++){
            calculated = calculated / base
        }
    }
    // Otherwise it is normal multiplication exponent
    else {
        for (var i = 1; i < exponent.val; i++){
            calculated = calculated * base
        }
    }
    return calculated
}

// Adjust a float so that the 11th bit in the mantissa is 1, the whole number
Float16 normalizeFloat(int fraction, int exponent){
    var frac = fraction
    var exp = exponent
    // If the 11th digit is already the whole number 1
    if((frac & 0b1111100000000000) == 0 && (frac & 0b10000000000) == 0b10000000000){
        exp += 1
    }
    else{
        // If leftmost digit is further than mantissa max of 10, then shift right
        for (var j = 0; j < 10; j++){
            // If the left has no 1s, then stop shifting
            if((frac & 0b1111100000000000) == 0)
                break
            // Otherwise shift again
            frac = frac >> 1
            exp += 1
        }
        // Shift left until 11th digit is 1
        for (var i = 0; i < 12; i++){
            // If the left digit is 1, then stop shifting
            if((frac & 0b10000000000) == 0b10000000000)
                break
            // Otherwise shift again
            frac = frac << 1
            exp -= 1
        }
    }
    frac = frac&0b1111111111
    Float16 outFloat = { sign : 0, exponent : exp, fraction : frac };
    return outFloat
}

int deNormalizeFraction(int f, int exp){
    bool sn = (10-exp>60000)
    var vl = 10-exp
    // SignedInt powNum = { s : 0, val : 0 };
    if (sn){
        vl = 65535-(10-exp)
        // powNum.s = 1
    }
    // powNum.val = vl


    // return (f * pow(2, powNum))
    // If negative
    if(sn == 1){
        return f<<vl
    }
    // Otherwise shift normal way
    else{
        return f>>vl
    }
}

// Return the integer rounded approximation of a float
int FloatToInt(Float16 fl){
    int tmpF = fl.fraction + 0b10000000000
    // tmpF = TruncateTrailingZeros(tmpF)

    int tmpE = fl.exponent - 15

    // int out = tmpF >> get_shift_amnt(tmpF, tmpE)

    int out = deNormalizeFraction(tmpF, tmpE)
    return out
}

// // Return the integer rounded approximation of a float
// int FloatToInt(Float16 fl){
//     int tmpF = fl.fraction
//     tmpF = TruncateTrailingZeros(tmpF)
//     Float16 fFrac = { sign : 0, exponent : 1, fraction : tmpF };

//     int tmpE = fl.exponent - 15

//     // int out = tmpM >> get_shift_amnt(tmpM, tmpE)

//     int out = deNormalizeFraction(tmpM, tmpE)
//     return out
// }

// Float16 FloatToInt(Float16 fl)
// {
//     var fractionBits = 10   //  Number of bits in signficand field.
//     var ExponentBits = 5   //  Number of bits in exponent field.

//     var ExponentMaximum = (1 << ExponentBits) - 1
//     var ExponentBias = 15


//     /*  We are given a fraction field as an integer, but it is used as the
//         value of a binary numeral consisting of “.” followed by the fraction
//         bits.  That value equals the integer divided by 2 to the power of the
//         number of fraction bits.  Define a constant with that value to be
//         used for converting the fraction field to represented value.
//     */
//     var fractionRatio = 0b1 << fractionBits

//     /*  Decode the sign field:

//             If the sign bit is 0, the sign is +, for which we use +1.
//             If the sign bit is 1, the sign is -, for which we use -1.
//     */
//     // var Sign = fl.sign ? -1. : +1.;
//     var Sign = 1

//     /*  When the exponent field is all ones, the value represented is a
//         NaN or infinity:

//             If the fraction field is zero, it is an infinity.
//             Otherwise, it is a NaN.  In either case, the sign should be
//             preserved.

//         Note this is a simple demonstration implementation that does not
//         preserve the bits in the fraction field of a NaN -- we just
//         return the generic NAN without attempting to set its fraction
//         bits.
//     */
//     if (fl.exponent==ExponentMaximum)
//     {
//         return Sign * 0b1111111111111111
//     }

//     /*  When the exponent field is zero, the value represented is subnormal:

//             The exponent represented is 1 - ExponentBias, and the
//             fraction represented is the value given by the binary
//             numeral “0.” followed by the fraction bits.
//     */
//     else if (fl.exponent==0)
//     {
//         int Exponent = 1 - ExponentBias
//         int fraction = 0 + fl.fraction / fractionRatio
//         return Sign * (fraction* pow(2,Exponent))
//     }
    
//     /*  When the exponent field is not all zeros or all ones, the value
//         represented is a normal number:

//             The exponent represented is fl.exponent - ExponentBias, and
//             the fraction represented is the value given by the binary
//             numeral “1.” followed by the fraction bits.
//     */
//     else
//     {
//         int Exponent = fl.exponent - ExponentBias
//         int fraction = 1 + fl.fraction / fractionRatio
//         return Sign * (fraction* pow(2,Exponent))
//     }
// }

// Return the integer rounded approximation of a float
Float16 IntToFloat(int x){
    // Find the exponent, by shifting left until the largest digit is reached
    var count = 1
    var tmp = x
    var mask = 1
    for (var i = 0; i < 16; i++){
        // If the first digit is 1, then stop shifting because we have the count
        if((tmp & 0b1000000000000000) == 0b1000000000000000)
            break
        // Otherwise shift again
        tmp = tmp << 1
        count += 1
    }
    // Get exponent from count, then add offset of 15 for float format
    var exp = (15-count)+15
    
    // // Only get the right part of the input number, since 1 is already included in mantissa
    // mask = ~(mask << (16-count))
    // mask = ~(pow(2, 16-count))
    // var mant = x & (mask)
    var mant = x
    // If the mantissa is >= 10 bits long already, only use first 10
    if(mant > 0b11111111111){
        mant = mant >> ((16-count)-11)
        // exp += (16-count-11)
        // write('X')
    }
    else if(mant < 0b10000000000){
        mant = mant << (11-(16-count))
        // exp += (16-count-11)
        // write('Q')
    }
    //else{
    //     // var mant = (x & (~mask)) << (10-((16-count)-1))
    //     // The mantissa needs to be 10 bits long, so add zeros to the right side until it is:
    //     for (var i = 0; i < 11; i++){
    //         // If the first digit is 1, then stop shifting
    //         if(mant >= 1024)
    //             break
    //         // Otherwise shift again
    //         mant = mant << 1
    //         write('Q')
    //         exp += 1
    //     }
    // }

    // mant = mant & 0b10000000000
    // newline()
    // write(':')
    // write_binary(mant)
    // // write_int(mask)
    // write(':')

    // For a whole number
    // Float16 outFloat = { sign : 0, exponent : exp, fraction : mant };
    // newline()
    // write('e')
    // write(':')
    // write_binary(exp)
    // write('f')
    // write(':')
    // write_binary(mant)
    // write_float(outFloat)
    Float16 outFloat = normalizeFloat(mant, exp);
    // outFloat = normalizeFloat(outFloat)

    return outFloat
}

int AddFloats(Float16 floatA, Float16 floatB){
    int out = 0
    var fracA = floatA.fraction
    var expA = floatA.exponent
    var fracB = floatB.fraction
    var expB = floatB.exponent
    // floatA = normalizeFloat(fracA, expA)
    // floatB = normalizeFloat(fracB, expB)
    // newline()
    // write_binary(floatA.exponent)
    // newline()
    // write_binary(floatB.exponent)
    // newline()
    // If the exponents are different, then we need to make the float with the smaller exponent the same as the larger one
    if(floatA.exponent > floatB.exponent){
        int tmpMB = ((floatB.fraction+0b10000000000)>>(floatA.exponent-floatB.exponent))
        int tmpMA = floatA.fraction+0b10000000000
        // write(' ')
        // write('d')
        // write(':')
        // write(' ')
        // write_int((floatB.exponent-floatA.exponent))
        // newline()
        // write('a')
        // write(':')
        // write_binary(tmpMA)
        // write('b')
        // write(':')
        // write_binary(tmpMB)
        
        // if(floatB.sign != 0)
        //     tmpMB = Negative(tmpMB)
        // if(floatA.sign != 0)
        //     tmpMA = Negative(tmpMA)
        
        int tmpM = tmpMA+tmpMB
        // newline()
        // write_binary(tmpM)
        Float16 outFloat = { sign : floatA.sign, exponent : floatA.exponent, fraction : tmpM };
        if ((tmpM & 0b10000000000) != 0b10000000000) // If the 11th bit is 0, then normalize
            outFloat = normalizeFloat(tmpM, floatB.exponent)
        // newline()
        // write_float(outFloat)
        // newline()
        // write_binary(outFloat.fraction)
        // newline()
        // write_float(outFloat)
        out = FloatToInt(outFloat)
    }
    // 150+500
    else if(floatA.exponent < floatB.exponent){
        int tmpMB = floatB.fraction+0b10000000000
        int tmpMA = ((floatA.fraction+0b10000000000)>>(floatB.exponent-floatA.exponent))
        // write(' ')
        // write('d')
        // write(':')
        // write(' ')
        // write_int((floatB.exponent-floatA.exponent))
        // newline()
        // write('a')
        // write(':')
        // write_binary(tmpMA)
        // write('b')
        // write(':')
        // write_binary(tmpMB)
        
        // if(floatB.sign != 0)
        //     tmpMB = Negative(tmpMB)
        // if(floatA.sign != 0)
        //     tmpMA = Negative(tmpMA)
        
        int tmpM = tmpMA+tmpMB
        // newline()
        // write_binary(tmpM)
        Float16 outFloat = { sign : floatA.sign, exponent : floatB.exponent, fraction : tmpM };
        if ((tmpM & 0b10000000000) != 0b10000000000) // If the 11th bit is 0, then normalize
            outFloat = normalizeFloat(tmpM, floatB.exponent)
        // newline()
        // write_float(outFloat)
        // newline()
        // write_binary(outFloat.fraction)
        // newline()
        // write_float(outFloat)
        out = FloatToInt(outFloat)
    }
    // Else the exponents are the same, so no need to change them
    else {
        int tmpMB = floatB.fraction+0b10000000000
        int tmpMA = floatA.fraction+0b10000000000
        
        if(floatB.sign != 0)
            tmpMB = Negative(tmpMB)
        if(floatA.sign != 0)
            tmpMA = Negative(tmpMA)
        
        int tmpM = tmpMA+tmpMB
        // newline()
        // write_binary(tmpM)
        Float16 outFloat = normalizeFloat(tmpM, floatB.exponent)
        // newline()
        // write_binary(outFloat.fraction)
        // newline()
        // write_float(outFloat)
        out = FloatToInt(outFloat)
    }

    return out
}

int MultFloats(Float16 floatA, Float16 floatB){
    int out = 0
    int tmpMA = floatA.fraction + 0b10000000000
    int tmpMB = floatB.fraction + 0b10000000000
    // if(floatA.exponent > floatB.exponent){
    //     int tmpMA = floatA.fraction<<(floatA.exponent-floatB.exponent)
    //     int tmpMB = floatB.fraction
    // }
    // else if(floatA.exponent < floatB.exponent){
    //     int tmpMA = floatA.fraction
    //     int tmpMB = floatB.fraction<<(floatB.exponent-floatA.exponent)
    // }
    // else {
    //     int tmpMA = floatA.fraction>>1
    //     int tmpMB = floatB.fraction>>1
    // }
    int tmpM = tmpMA*tmpMB
    Float16 outFloat = { sign : floatA.sign, exponent : ((floatA.exponent+floatB.exponent)-15), fraction : tmpM };
    out = FloatToInt(outFloat)
    
    return out
}

// int SubFloats(int floatA.sign, int floatA.exponent, int floatA.fraction, int floatB.sign, int floatB.exponent, int floatB.fraction){
//     return AddFloats(floatA.sign, floatA.exponent, floatA.fraction, !floatB.sign, floatB.exponent, floatB.fraction)
// }

// Float16 f16 = { sign : 1, exponent : 5, fraction : 10 };
// write_int(f16.exponent)
var correctVal = 0
var val = 0

// t1: Float to int 1024
correctVal = 1024
ChangeHighlightColor(0, 128, 128)
write('t')
write('1')
write(' ')
Float16 t1 = IntToFloat(correctVal);
val = FloatToInt(t1)
// newline()
// write_float(t1)
if(WithinRange(correctVal, val, 10) == false)
    ChangeHighlightColor(230, 0, 0)
else
    ChangeHighlightColor(0, 230, 0)
write_int(val)
write(' ')
ChangeHighlightColor(128, 128, 0)
write_int(correctVal)
ChangeHighlightColor(0, 128, 128)
newline()
newline()

// t1: Float to int 2751
correctVal = 2751
ChangeHighlightColor(0, 128, 128)
write('t')
write('2')
write(' ')
Float16 t1 = IntToFloat(correctVal);
val = FloatToInt(t1)
// newline()
// write_float(t1)
if(WithinRange(correctVal, val, 10) == false)
    ChangeHighlightColor(230, 0, 0)
else
    ChangeHighlightColor(0, 230, 0)
write_int(val)
write(' ')
ChangeHighlightColor(128, 128, 0)
write_int(correctVal)
ChangeHighlightColor(0, 128, 128)
newline()
newline()
// write_binary(val) // Binary should be: 0000000010100000

// // t2: Add floats 160 + 160 = 320
// correctVal = 320
// ChangeHighlightColor(0, 128, 128)
// write('t')
// write('2')
// write(' ')
// Float16 t2a = { sign : 0, exponent : 0b10110, fraction : 0b0100000000 };
// Float16 t2b = { sign : 0, exponent : 0b10110, fraction : 0b0100000000 };
// val = AddFloats(t2a, t2b)
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()
// newline()

// t3: Add floats 150 + 500 = 650
correctVal = 150+500
ChangeHighlightColor(0, 128, 128)
write('t')
write('3')
write(' ')
Float16 t3a = IntToFloat(150);
write_int(FloatToInt(t3a))
Float16 t3b = IntToFloat(500);
write('+')
write_int(FloatToInt(t3b))
var val = AddFloats(t3a, t3b)
if(WithinRange(correctVal, val, 10) == false)
    ChangeHighlightColor(230, 0, 0)
else
    ChangeHighlightColor(0, 230, 0)
write('=')
write_int(val)
write(' ')
ChangeHighlightColor(128, 128, 0)
write_int(correctVal)
ChangeHighlightColor(0, 128, 128)
newline()
newline()

// t4: Add floats 700 + 140 = 840
correctVal = 700 + 140
ChangeHighlightColor(0, 128, 128)
write('t')
write('3')
write(' ')
Float16 t3a = IntToFloat(700);
write_int(FloatToInt(t3a))
Float16 t3b = IntToFloat(140);
write('+')
write_int(FloatToInt(t3b))
var val = AddFloats(t3a, t3b)
if(WithinRange(correctVal, val, 10) == false)
    ChangeHighlightColor(230, 0, 0)
else
    ChangeHighlightColor(0, 230, 0)
write('=')
write_int(val)
write(' ')
ChangeHighlightColor(128, 128, 0)
write_int(correctVal)
ChangeHighlightColor(0, 128, 128)
newline()
newline()

// t5: Add floats 9000 + 9000 = 18000
correctVal = 9000 + 9000
ChangeHighlightColor(0, 128, 128)
write('t')
write('5')
write(' ')
Float16 t3a = IntToFloat(9000);
write_int(FloatToInt(t3a))
Float16 t3b = IntToFloat(9000);
write('+')
write_int(FloatToInt(t3b))
var val = AddFloats(t3a, t3b)
if(WithinRange(correctVal, val, 10) == false)
    ChangeHighlightColor(230, 0, 0)
else
    ChangeHighlightColor(0, 230, 0)
write('=')
write_int(val)
write(' ')
ChangeHighlightColor(128, 128, 0)
write_int(correctVal)
ChangeHighlightColor(0, 128, 128)
newline()
newline()

// // t4: Multiply floats 10 * 2 = 20
// correctVal = 20
// write('t')
// write('4')
// write(' ')
// Float16 t4a = IntToFloat(10);
// Float16 t4b = IntToFloat(2);
// val = MultFloats(t4a, t4b)
// if(WithinRange(correctVal, val, 10) == false)
//     ChangeHighlightColor(230, 0, 0)
// else
//     ChangeHighlightColor(0, 230, 0)
// write_int(val)
// write(' ')
// ChangeHighlightColor(128, 128, 0)
// write_int(correctVal)
// ChangeHighlightColor(0, 128, 128)
// newline()
// newline()
// // write_binary(val)
// // newline()

// // t5: Float to int 1.7
// write('t')
// write('5')
// write(' ')
// Float16 t5 = { sign : 0, exponent : 0b01111, fraction : 0b1011001100 };
// val = FloatToInt(t5)
// write_int(val)
// newline()
// newline()

// // t6: Int to Float to int 0 through 10000
// write('t')
// write('6')
// write(' ')
// // Iterate through all values 0 through 10000, and count the number of incorrect
// var numWrong = 0
// var startWrong = 0
// var endWrong = 0
// for (var i = 0; i < 10000; i++){
//     correctVal = i
//     Float16 t6 = IntToFloat(correctVal);
//     // t6 = normalizeFloat(t6.fraction, t6.exponent)
//     // Float16 t6 = { sign : 0, exponent : 0b10100, fraction : 0b0010000000 };
//     val = FloatToInt(t6)
//     if(WithinRange(correctVal, val, 10) == false){
//         numWrong += 1
//         if(startWrong==0)
//             startWrong = i

//         endWrong = i
//         // write_int(i)
//         // break
//     }
// }
// write(' ')
// write('w')
// write('r')
// write('o')
// write('n')
// write('g')
// write(':')
// write(' ')
// ChangeHighlightColor(128, 0, 128)
// if(numWrong > 0)
//     write_int(numWrong)
// else{
//     ChangeHighlightColor(0, 230, 0)
//     write('n')
//     write('o')
//     write('n')
//     write('e')
// }
// newline()
// ChangeHighlightColor(0, 128, 128)
// write('s')
// write('t')
// write('a')
// write(':')
// write(' ')
// write_int(startWrong)
// newline()
// write('e')
// write('n')
// write('d')
// write(':')
// write(' ')
// write_int(endWrong)
// newline()


//cout << DecimalToBinaryString(val) << " : " << val << endl

//    cout << "Float To Int: 13.78" <<endl;
//    val = FloatToInt(0, 0b10010, 0b1011100011);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Float To Int: 2100" <<endl;
//    val = FloatToInt(0, 0b11010, 0b0000011010);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Float To Int: 3.141" <<endl;
//    val = FloatToInt(0, 0b10000, 0b1001001000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Add floats: 3.141 + 20 = 23.141" <<endl;
//    val = AddFloats(0, 0b10000, 0b1001001000, 0, 0b10011, 0b0100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Add floats: 281 + 425.5 = 706.5" <<endl;
//    val = AddFloats(0, 0b10111, 0b0001100100, 0, 0b10111, 0b1010100110);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Sub floats: 800 - 425.5 = 374.5" <<endl;
//    val = SubFloats(0, 0b11000, 0b1001000000, 0, 0b10111, 0b1010100110);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 15 * 3.5 = 52.5" <<endl;
//    val = MultFloats(0, 0b10010, 0b1110000000, 0, 0b10000, 0b1100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 300 * 3.5 = 1050" <<endl;
//    val = MultFloats(0, 0b10111, 0b0010110000, 0, 0b10000, 0b1100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 300 * 0.5 = 150" <<endl;
//    val = MultFloats(0, 0b10111, 0b0010110000, 0, 0b01110, 0b0000000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 0.5 * 0.5 = 0.25" <<endl;
//    val = MultFloats(0, 0b01110, 0b0000000000, 0, 0b01110, 0b0000000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

while (true) {
    
}




struct Float16 {
    int sign : 1
    int exponent : 5
    int fraction : 10
}

struct SignedInt {
    int s
    int val
}
