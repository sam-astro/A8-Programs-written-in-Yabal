
var floats = create_pointer<Float16>(0x3FFE);
var signedInts = create_pointer<SignedInt>(0x4000);
var chars = create_pointer(53546, 1)
var offset = 0


void write(int c) {
    chars[offset] = c
    offset++
}

// void writeStr(int s) {
//     var size = sizeof(s)
//     for (var i = 0; i < size; i++) {
//         write(s[i])
//     }
// }

void newline(){
    offset = offset / 18 * 18 + 18
}

void write_int(int value) {
    var reverser = create_pointer(65530, 0)
    var i = 0
    for (var i = 0; i < 5; i++){
        reverser[i] = 0
    }
    while (value > 0) {
        var char = (value % 10) switch {
            1 => '1',
            2 => '2',
            3 => '3',
            4 => '4',
            5 => '5',
            6 => '6',
            7 => '7',
            8 => '8',
            9 => '9',
            _ => '0'
        }

        reverser[i] = char
        value = value / 10
        i += 1
    }
    for (var i = 0; i < 5; i++){
        write(reverser[4-i])
    }
}

void write_binary(int value) {
    var reverser = create_pointer(65519, 0)
    var i = 0
    for (var i = 0; i < 16; i++){
        reverser[i] = 0
    }
    while (value > 0) {
        var char = (value & 1) switch {
            1 => '1',
            _ => '0'
        }

        reverser[15-i] = char
        value = value >> 1
        i += 1
    }
    for (var i = 0; i < 16; i++){
        write(reverser[i])
    }
}

int TruncateTrailingZeros(int x){
    var o = x
    for (var i = 0; i < 16; i++){
        // If the last digit is 1, then stop shifting
        if((o & 1) == 1)
            break
        // Otherwise shift again
        o = o >> 1
    }
    return o
}

// void write_float(Float16 value) {
//     if (value.sign == 1) {
//         write('-')
//     }

//     write_int(value.exponent)
//     write('.')
//     write_int(value.fraction)
// }


int Negative(int x){
    return (~x)+1
}


int get_shift_amnt(int man, int exp){
    return 10-exp
}

// string DecimalToBinaryString(int a)
// {
//     uint b = (uint)a
//     string binary = ""
//     uint mask = 0x80000000u
//     while (mask > 0)
//     {
//         binary += ((b & mask) == 0) ? '0' : '1'
//         mask >>= 1
//     }
//     return binary
// }

// Returns the integer base raised to the power integer exponent
int pow(int base, SignedInt exponent){
    var calculated = base
    // If the exponent is negative, we divide each time instead of multiply
    if(exponent.s == 1){
        for (var i = 1; i < exponent.val; i++){
            calculated = calculated / base
        }
    }
    // Otherwise it is normal multiplication exponent
    else {
        for (var i = 1; i < exponent.val; i++){
            calculated = calculated * base
        }
    }
    return calculated
}

Float16 normalizeFloat(Float16 f){
    
}

int deNormalizeFraction(int f, int exp){
    bool sn = (10-exp>60000)
    var vl = 10-exp
    // SignedInt powNum = { s : 0, val : 0 };
    if (sn){
        vl = 65535-(10-exp)
        // powNum.s = 1
    }
    // powNum.val = vl


    // return (f * pow(2, powNum))
    // If negative
    if(sn == 1){
        return f<<vl
    }
    // Otherwise shift normal way
    else{
        return f>>vl
    }
}

// Return the integer rounded approximation of a float
int FloatToInt(Float16 fl){
    int tmpF = fl.fraction + 0b10000000000
    // tmpF = TruncateTrailingZeros(tmpF)

    int tmpE = fl.exponent - 15

    // int out = tmpF >> get_shift_amnt(tmpF, tmpE)

    int out = deNormalizeFraction(tmpF, tmpE)
    return out
}

// // Return the integer rounded approximation of a float
// int FloatToInt(Float16 fl){
//     int tmpF = fl.fraction
//     tmpF = TruncateTrailingZeros(tmpF)
//     Float16 fFrac = { sign : 0, exponent : 1, fraction : tmpF };

//     int tmpE = fl.exponent - 15

//     // int out = tmpM >> get_shift_amnt(tmpM, tmpE)

//     int out = deNormalizeFraction(tmpM, tmpE)
//     return out
// }

// Float16 FloatToInt(Float16 fl)
// {
//     var fractionBits = 10   //  Number of bits in signficand field.
//     var ExponentBits = 5   //  Number of bits in exponent field.

//     var ExponentMaximum = (1 << ExponentBits) - 1
//     var ExponentBias = 15


//     /*  We are given a fraction field as an integer, but it is used as the
//         value of a binary numeral consisting of “.” followed by the fraction
//         bits.  That value equals the integer divided by 2 to the power of the
//         number of fraction bits.  Define a constant with that value to be
//         used for converting the fraction field to represented value.
//     */
//     var fractionRatio = 0b1 << fractionBits

//     /*  Decode the sign field:

//             If the sign bit is 0, the sign is +, for which we use +1.
//             If the sign bit is 1, the sign is -, for which we use -1.
//     */
//     // var Sign = fl.sign ? -1. : +1.;
//     var Sign = 1

//     /*  When the exponent field is all ones, the value represented is a
//         NaN or infinity:

//             If the fraction field is zero, it is an infinity.
//             Otherwise, it is a NaN.  In either case, the sign should be
//             preserved.

//         Note this is a simple demonstration implementation that does not
//         preserve the bits in the fraction field of a NaN -- we just
//         return the generic NAN without attempting to set its fraction
//         bits.
//     */
//     if (fl.exponent==ExponentMaximum)
//     {
//         return Sign * 0b1111111111111111
//     }

//     /*  When the exponent field is zero, the value represented is subnormal:

//             The exponent represented is 1 - ExponentBias, and the
//             fraction represented is the value given by the binary
//             numeral “0.” followed by the fraction bits.
//     */
//     else if (fl.exponent==0)
//     {
//         int Exponent = 1 - ExponentBias
//         int fraction = 0 + fl.fraction / fractionRatio
//         return Sign * (fraction* pow(2,Exponent))
//     }
    
//     /*  When the exponent field is not all zeros or all ones, the value
//         represented is a normal number:

//             The exponent represented is fl.exponent - ExponentBias, and
//             the fraction represented is the value given by the binary
//             numeral “1.” followed by the fraction bits.
//     */
//     else
//     {
//         int Exponent = fl.exponent - ExponentBias
//         int fraction = 1 + fl.fraction / fractionRatio
//         return Sign * (fraction* pow(2,Exponent))
//     }
// }

// Return the integer rounded approximation of a float
Float16 IntToFloat(int x){
    // Find the exponent, by shifting left until the largest digit is reached
    var count = 1
    var tmp = x
    var mask = 0b1
    for (var i = 0; i < 16; i++){
        // If the first digit is 1, then stop shifting because we have the count
        if((tmp & 0b1000000000000000) == 0b1000000000000000)
            break
        // Otherwise shift again
        tmp = tmp << 1
        count += 1
    }
    // Get exponent from count, then add offset of 15 for float format
    var exp = (16-count) + 15
    
    // Only get the right part of the input number, since 1 is already included in mantissa
    mask = mask << (16-count)
    var mant = x & (~mask)
    // The mantissa needs to be 10 bits long, so add zeros to the right side until it is:
    for (var i = 0; i < 16; i++){
        // If the first digit is 1, then stop shifting
        if((mant & 0b1000000000) == 0b1000000000)
            break
        // Otherwise shift again
        mant = mant << 1
    }

    // For a whole number
    Float16 outFloat = { sign : 0, exponent : exp, fraction : mant };

    return outFloat
}

int AddFloats(Float16 floatA, Float16 floatB){
    int out = 0
    if(floatA.exponent > floatB.exponent){
        //floatB.exponent = floatB.sign == 0 ? floatB.exponent : Negative(floatB.exponent);
        int tmpMA = floatB.fraction<<(floatA.exponent-floatB.exponent)
        int tmpMB = floatA.fraction
        
        if(floatB.sign != 0)
            tmpMA = Negative(tmpMA)
        if(floatA.sign != 0)
            tmpMB = Negative(tmpMB)
        
        int tmpM = tmpMA+tmpMB
        Float16 outFloat = { sign : floatA.sign, exponent : floatB.exponent+1, fraction : tmpM };
        out = FloatToInt(outFloat)
    }
    else if(floatA.exponent < floatB.exponent){
        int tmpMA = floatB.fraction
        int tmpMB = floatA.fraction<<(floatB.exponent-floatA.exponent)
        
        if(floatB.sign != 0)
            tmpMA = Negative(tmpMA)
        if(floatA.sign != 0)
            tmpMB = Negative(tmpMB)
        
        int tmpM = tmpMA+tmpMB
        Float16 outFloat = { sign : floatA.sign, exponent : floatA.exponent+1, fraction : tmpM };
        out = FloatToInt(outFloat)
    }
    else {
        int tmpMA = floatB.fraction>>1
        int tmpMB = floatA.fraction>>1
        
        if(floatB.sign != 0)
            tmpMA = Negative(tmpMA)
        if(floatA.sign != 0)
            tmpMB = Negative(tmpMB)
        
        int tmpM = tmpMA+tmpMB
        Float16 outFloat = { sign : floatA.sign, exponent : floatB.exponent+1, fraction : tmpM };
        out = FloatToInt(outFloat)
    }

    return out
}

int MultFloats(Float16 floatA, Float16 floatB){
    int out = 0
    int tmpMA = floatA.fraction + 0b10000000000
    int tmpMB = floatB.fraction + 0b10000000000
    // if(floatA.exponent > floatB.exponent){
    //     int tmpMA = floatA.fraction<<(floatA.exponent-floatB.exponent)
    //     int tmpMB = floatB.fraction
    // }
    // else if(floatA.exponent < floatB.exponent){
    //     int tmpMA = floatA.fraction
    //     int tmpMB = floatB.fraction<<(floatB.exponent-floatA.exponent)
    // }
    // else {
    //     int tmpMA = floatA.fraction>>1
    //     int tmpMB = floatB.fraction>>1
    // }
    int tmpM = tmpMA*tmpMB
    Float16 outFloat = { sign : floatA.sign, exponent : ((floatA.exponent+floatB.exponent)-15), fraction : tmpM };
    out = FloatToInt(outFloat)
    
    return out
}

// int SubFloats(int floatA.sign, int floatA.exponent, int floatA.fraction, int floatB.sign, int floatB.exponent, int floatB.fraction){
//     return AddFloats(floatA.sign, floatA.exponent, floatA.fraction, !floatB.sign, floatB.exponent, floatB.fraction)
// }

// Float16 f16 = { sign : 1, exponent : 5, fraction : 10 };
// write_int(f16.exponent)

// t1: Float to int 160
write('t')
write('1')
write(' ')
Float16 t1 = IntToFloat(7285);
var val = FloatToInt(t1)
write_int(val)
newline()
// write_binary(val) // Binary should be: 0000000010100000

// t2: Add floats 160 + 160 = 320
write('t')
write('2')
write(' ')
Float16 t2a = { sign : 0, exponent : 0b10110, fraction : 0b0100000000 };
Float16 t2b = { sign : 0, exponent : 0b10110, fraction : 0b0100000000 };
var val = AddFloats(t2a, t2b)
write_int(val)
newline()

// t3: Add floats 150 + 500 = 650
write('t')
write('3')
write(' ')
Float16 t3a = { sign : 0, exponent : 0b10110, fraction : 0b0010110000 };
write(' ')
write_int(FloatToInt(t3a))
Float16 t3b = { sign : 0, exponent : 0b10111, fraction : 0b1111010000 };
write('+')
write_int(FloatToInt(t3b))
var val = AddFloats(t3a, t3b)
write('=')
write_int(val)
newline()

// t4: Multiply floats 10 * 2 = 20
write('t')
write('4')
write(' ')
Float16 t4a = IntToFloat(10);
Float16 t4b = IntToFloat(2);
var val = MultFloats(t4a, t4b)
write_int(val)
newline()
write_binary(val)
newline()

// t5: Float to int 0.6
write('t')
write('5')
write(' ')
Float16 t5 = { sign : 0, exponent : 0b01110, fraction : 0b0011001100 };
var val = FloatToInt(t5)
write_int(val)
newline()

// t6: Int to Float to int 36
write('t')
write('6')
write(' ')
Float16 t6 = IntToFloat(1);
var val = FloatToInt(t6)
write_int(val)
newline()

//cout << DecimalToBinaryString(val) << " : " << val << endl

//    cout << "Float To Int: 13.78" <<endl;
//    val = FloatToInt(0, 0b10010, 0b1011100011);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Float To Int: 2100" <<endl;
//    val = FloatToInt(0, 0b11010, 0b0000011010);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Float To Int: 3.141" <<endl;
//    val = FloatToInt(0, 0b10000, 0b1001001000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Add floats: 3.141 + 20 = 23.141" <<endl;
//    val = AddFloats(0, 0b10000, 0b1001001000, 0, 0b10011, 0b0100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Add floats: 281 + 425.5 = 706.5" <<endl;
//    val = AddFloats(0, 0b10111, 0b0001100100, 0, 0b10111, 0b1010100110);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Sub floats: 800 - 425.5 = 374.5" <<endl;
//    val = SubFloats(0, 0b11000, 0b1001000000, 0, 0b10111, 0b1010100110);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 15 * 3.5 = 52.5" <<endl;
//    val = MultFloats(0, 0b10010, 0b1110000000, 0, 0b10000, 0b1100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 300 * 3.5 = 1050" <<endl;
//    val = MultFloats(0, 0b10111, 0b0010110000, 0, 0b10000, 0b1100000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 300 * 0.5 = 150" <<endl;
//    val = MultFloats(0, 0b10111, 0b0010110000, 0, 0b01110, 0b0000000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

//    cout << "Mult floats: 0.5 * 0.5 = 0.25" <<endl;
//    val = MultFloats(0, 0b01110, 0b0000000000, 0, 0b01110, 0b0000000000);
//    cout << DecimalToBinaryString(val) << " : " << val << endl;
//    cout<<endl;

while (true) {
    
}




struct Float16 {
    int sign : 1
    int exponent : 5
    int fraction : 10
}

struct SignedInt {
    int s
    int val
}